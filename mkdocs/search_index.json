{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Worldpay Within\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \nWhat it is\n\n    \nWorldpay Within is an embeddable payments agent that can be 'plugged' into your app or a smart device. It then lets you discover other devices and pay for that device\u2019s service. We've got four wrappers you can use: \n\n    \nAPI Spec\n\n  \n\n\n\n\n\n\n  \n\n     \n\n  \n\n  \n\n    \nWhy use it\n\n    \nYou can make or take payments from an IoT device. Maybe your car is running out of fuel and it broadcasts a need for petrol; perhaps you're a petrol station that has a service to offer.\n\n  \n\n\n\n\n\n\n  \n\n    \n\n  \n\n  \n\n    \nHow it works\n\n    \nThere are four simple interactions that take place with Worldpay Within: \nDiscover\n, \nSelect\n, \nPay\n and \nRelease\n.\n\n    \nHow it works\n\n  \n\n\n\n\n\n\n\n\nA demonstration\n\n\n\n\n\nWhat it is\n\n\nDriven by the \nInternet of Things\n, Worldpay is keen to demonstrate how you can integrate payments into everyday objects. So we created Worldpay Within - an embeddable payments agent that can be 'plugged' into your app or a smart device. It then lets you discover other devices and pay for that device\u2019s service.\n\n\nWe\u2019ve got a series of \nopen source\n software development kits (SDKs) that let you make and accept payments from a range of devices. We\u2019ve got SDKs for \nnode.js\n, \nGo\n, \n.NET\n, Java and \nPython 2.7 and 3\n. You can download these SDKs, get playing, configure your setup, and recommend changes to our open source libraries.\n\n\nWhy use it\n\n\nYou might want to use Worldpay Within if you\u2019re a startup company that\u2019s creating technologies relating to the Internet of Things. Or perhaps you\u2019re a hobby developer who likes creating innovative technologies in your spare time.\n\n\nWorldpay Within provides you with the functionality and the SDKs to explore how the Internet of Things allows you to test the interaction between two devices and see how devices can make and receive payments.\n\n\nHow it works\n\n\nThere are four simple interactions that take place with Worldpay Within: \nDiscover\n, \nSelect\n, \nPay\n and \nRelease\n.\n\n\nImagine that a car needs some fuel. It stops by a petrol station and broadcasts that it needs fuel. The petrol station receives this signal, informs the car of how much fuel costs and what options are available, and once the shopper has made a choice, Worldpay will process the payment and inform the petrol station that it can fuel the car.\n\n\n\n\nA demonstration of how to use Worldpay Within in four easy interactions\n\n\n\n\nDiscover - \nThing A (shopper)\n broadcasts to \nThing B (merchant)\n that it requires something.\n\n\nSelect - When \nThing B\n receives \nThing A\u2019s\n broadcast, it presents the options and the shopper chooses one.\n\n\nPay - \nThing A\n pays.\n\n\nRelease - Worldpay sends \nThing B\n a secure token (a trusted trigger) to release the service to \nThing A.\n\n\n\n\nThe Internet of Things\n\n\nThe Internet of Things (IoT) is an initiative to connect everyday items to the internet. It could be a car which needs to pay for fuel or some repairs, or a fridge which needs to order some groceries.\n\n\nIt is estimated\n that there will be 6 billion devices connected to the IoT by the end of 2016 and 20 billion by 2020. Some of these devices will consume services from other devices for which a payment will be required.\n\n\nBy using a set of APIs, \u201cThing\u201d developers will be able to integrate Worldpay Within into their IoT device, enabling the \u201cThing\u201d to make and/or receive payments for services to and from other \u201cThings\u201d.\n\n\nWorldpay Within orchestrates smart things talking to each other and paying for services.\n\n\nHackathons\n\n\nIn 2016, Worldpay hosted the \nPayments \n IOT Hackathon\n in which we wanted to take digital payments to the next level. In 2017, we're hosting another Hackathon in Romania, in which we release Worldpay Within.\n\n\nWant to find out more? Head over to the \nHackathons\n page.\n\n\nIt's open source\n\n\nWorldpay Within is open source, so why not give it a go yourself? You can find the GitHub library \nhere.\n\n\nIt's still an alpha based experiment, but we're actively building new features (and bug fixes) and are concurrently working on evolving the security architecture so we can take real payments.\n\n\nWe'd love to see what you can come up with, so why not become a contributor? Head over to the \nIssues page\n to see how you can help. \n\n\nGet the SDKs\n\n\nWorldpay Within's SDK is written in GoLang and runs on smart devices, including Raspberry Pi. It lets you make and receive payments within the IoT. We've got wrappers in these languages:\n\n\n\n  \nGo\n\n  \nJava\n\n  \n.NET\n\n  \nPython\n\n  \nNode.js\n\n\n\n\n\nContact us\n\n\nIf you've got any questions, or if you want to find out more, why not give us a shout at \n.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-worldpay-within", 
            "text": "", 
            "title": "Welcome to Worldpay Within"
        }, 
        {
            "location": "/#a-demonstration", 
            "text": "", 
            "title": "A demonstration"
        }, 
        {
            "location": "/#what-it-is", 
            "text": "Driven by the  Internet of Things , Worldpay is keen to demonstrate how you can integrate payments into everyday objects. So we created Worldpay Within - an embeddable payments agent that can be 'plugged' into your app or a smart device. It then lets you discover other devices and pay for that device\u2019s service.  We\u2019ve got a series of  open source  software development kits (SDKs) that let you make and accept payments from a range of devices. We\u2019ve got SDKs for  node.js ,  Go ,  .NET , Java and  Python 2.7 and 3 . You can download these SDKs, get playing, configure your setup, and recommend changes to our open source libraries.", 
            "title": "What it is"
        }, 
        {
            "location": "/#why-use-it", 
            "text": "You might want to use Worldpay Within if you\u2019re a startup company that\u2019s creating technologies relating to the Internet of Things. Or perhaps you\u2019re a hobby developer who likes creating innovative technologies in your spare time.  Worldpay Within provides you with the functionality and the SDKs to explore how the Internet of Things allows you to test the interaction between two devices and see how devices can make and receive payments.", 
            "title": "Why use it"
        }, 
        {
            "location": "/#how-it-works", 
            "text": "There are four simple interactions that take place with Worldpay Within:  Discover ,  Select ,  Pay  and  Release .  Imagine that a car needs some fuel. It stops by a petrol station and broadcasts that it needs fuel. The petrol station receives this signal, informs the car of how much fuel costs and what options are available, and once the shopper has made a choice, Worldpay will process the payment and inform the petrol station that it can fuel the car.   A demonstration of how to use Worldpay Within in four easy interactions   Discover -  Thing A (shopper)  broadcasts to  Thing B (merchant)  that it requires something.  Select - When  Thing B  receives  Thing A\u2019s  broadcast, it presents the options and the shopper chooses one.  Pay -  Thing A  pays.  Release - Worldpay sends  Thing B  a secure token (a trusted trigger) to release the service to  Thing A.", 
            "title": "How it works"
        }, 
        {
            "location": "/#the-internet-of-things", 
            "text": "The Internet of Things (IoT) is an initiative to connect everyday items to the internet. It could be a car which needs to pay for fuel or some repairs, or a fridge which needs to order some groceries.  It is estimated  that there will be 6 billion devices connected to the IoT by the end of 2016 and 20 billion by 2020. Some of these devices will consume services from other devices for which a payment will be required.  By using a set of APIs, \u201cThing\u201d developers will be able to integrate Worldpay Within into their IoT device, enabling the \u201cThing\u201d to make and/or receive payments for services to and from other \u201cThings\u201d.  Worldpay Within orchestrates smart things talking to each other and paying for services.", 
            "title": "The Internet of Things"
        }, 
        {
            "location": "/#hackathons", 
            "text": "In 2016, Worldpay hosted the  Payments   IOT Hackathon  in which we wanted to take digital payments to the next level. In 2017, we're hosting another Hackathon in Romania, in which we release Worldpay Within.  Want to find out more? Head over to the  Hackathons  page.", 
            "title": "Hackathons"
        }, 
        {
            "location": "/#its-open-source", 
            "text": "Worldpay Within is open source, so why not give it a go yourself? You can find the GitHub library  here.  It's still an alpha based experiment, but we're actively building new features (and bug fixes) and are concurrently working on evolving the security architecture so we can take real payments.  We'd love to see what you can come up with, so why not become a contributor? Head over to the  Issues page  to see how you can help.", 
            "title": "It's open source"
        }, 
        {
            "location": "/#get-the-sdks", 
            "text": "Worldpay Within's SDK is written in GoLang and runs on smart devices, including Raspberry Pi. It lets you make and receive payments within the IoT. We've got wrappers in these languages:  \n   Go \n   Java \n   .NET \n   Python \n   Node.js", 
            "title": "Get the SDKs"
        }, 
        {
            "location": "/#contact-us", 
            "text": "If you've got any questions, or if you want to find out more, why not give us a shout at  .", 
            "title": "Contact us"
        }, 
        {
            "location": "/dotnet/", 
            "text": ".NET Software Development Kit (SDK)\n\n\nThe .NET implementation for the Worldpay Within IoT payment SDK. This SDK, or Software Development Kit, enables smart devices to discover each other, negogiate a price for services, make a payment (through the Worldpay Online Payment gateway) for services, and then consume services via a \ntrusted trigger\n. For more information see our documentation website \nhere\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have the .NET 4.5 framework and Visual Studio 2017 (any edition) installed on your system. We've tested this wrapper with Visual 2017 Community Edition.\n\n\nYou should create an account with Worldpay Online so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK. \n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet Started\n\n\nThe .NET Worldpay Within SDK provides a convenient entry point for application developers who wish to create applications using the Worldpay Within SDK.\n\n\nCurrently, there are no \nNuGet\n published libraries for the SDK. This issue is being tracked in \nIssue #1 on GitHub\n.\n\n\nFor now, you will need to build the project yourself, by following these steps:\n\n\n\n\nClone or download the repository, e.g. \ngit clone git@github.com:WPTechInnovation/wpw-sdk-dotnet.git\n. See the \nproject homepage\n on GitHub for more options.\n\n\nOpen up the solution file in Visual Studio 2017 (community edition or better).\n\n\nBuild the solution.  Note that you must be connected to the Internet for nuget dependencies to be downloaded:\n\n\nApacheThrift 0.10.0\n\n\nCommon.Logging 3.3.1\n\n\nCommon.Logging.Core 3.3.1\n\n\n\n\n\n\nDownload the RPC Agent binary build for your platform. The RPC Agents can be downloaded from \nthe wpw-sdk-iot-core\n project.\n\n\nTo configure the .NET SDK to find the agent, download the agent in to a directory named bin and set a \nWPW_HOME\n environment variable to point to the directory above it. For example, if \nrpc-agent-windows-386.exe\n is installed in \nC:\\users\\Andy\\wpw\\bin\n, then set \nWPW_HOME\n to \nC:\\users\\Andy\\wpw\n.\n\n\n\n\n\n\n\n\nRun the examples\n\n\nOnce you've loaded the projects in to Visual Studio and built the project successfully (please note you can\n report any problems or errors to us\n on Github).\n\n\nTo run a sample app, run the \nWorldpay.Within.Sample\n project.\n\n\nWe'd recommend using your own test API keys for this. We've left our ones in the code, so that it \"just works\", but you won't be able to see the payments with our keys unless you change them. To do this, open \nSimpleProducer.cs\n and search for \nMerchantServiceKey\n in the \nPSPConfig\n declaration you can replace the existing MerchantServiceKey with your own value. \n\n\nThe sample application is a Windows console application. To make a simple payment, do the following:\n\n\n\n\nSelect option 1 \nStart Simple Producer\n. This will start a local RPC Agent and register a separate producer with it. Ths producer has a very simple service declaration.\n\n\nSelect option 3 \nConsume Purchase\n. This will start another RPC Agent and attempt to consume the first product of the first service it finds on the network. (This will most likely be your producer.)\n\n\n\n\nThe sample application produces lots of logging, you can control this by editing the \nApp.config\n file in the root of the sample project directory.\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys:\n1. Login to \nWorldpay Online\n.\n1. You'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\nIf you've used Worldpay's own test API keys\n1. Login to \nWorldpay Online\n.\n1. Got to \nSettings \n API keys\n and get your test keys.\n1. Replace the keys in \nSimpleProducer.cs\n.\n\n\nRe-run the sample application and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\nSo what's happening?\n\n\n\n\nYou can see there are four phases: \nDiscover\n, \nNegotiate\n, \nPay\n, and \nDeliver\n. For more information, see \nWorldpay Within\n.\n\n\nIntroduction to the different .NET projects\n\n\nWorldpay.Within\n\n\nThis is the main .NET wrapper entry point assembly. The public API is contained within here, inside the \nWorldpay.Within\n package.\n\n\nYou can use Sandcastle to build the docs, however they will be published online at some point (see \nIssue 2\n).\n\n\nWorldpay.Within.Rpc\n\n\nThis project contains nothing but the generated RPC wrappers for Thrift; you never edit code in here. This is a separate project because the style and organisation of the code generated by the Thrift compiler is pretty poor; this approach isolates this to a single project.\n\n\nYou can rebuild this code first deleting all the existing source files and their directories, to clear out any existing code that may have been moved or removed in a new version, then running the Thrift compiler:\n\n\nthrift-0.10.0.exe -r -out %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\wrappers\\dotnet\\Worldpay.Within\\Worldpay.Within.Rpc --gen csharp:nullable,union %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\rpc\\wpwithin.thrift\n\n\n\n\nThe \n-r\n is there just for safety, in case subdirectories are used in future for storing dependent Thrift IDL files.\n\n\n\n\nNote that the above oaths assume that you have downloaded the \nWorldpay Within main SDK project\n in to a regular \"Go\" development struture. However, only the thrift interface files are actually required. You can grab those directly from here: \nhttps://github.com/WPTechInnovation/worldpay-within-sdk/tree/master/rpc\n. There are two files needed: \nwptypes.thrift\n and \nwpwithin.thrift\n, both files must be in the same directory.  They are not included within the .NET repository because they are centrally maintained and used to generate multiple language wrappers.\n\n\nBe sure to refresh the project source tree in Visual Studio to ensure that any newly generated files are included in the project. If you fail to do this, expect compile errors for missing types to be thrown.\n\n\nUsing in your own applications\n\n\nTo use Worldpay Within, add the following DLLs to your project path:\n\n\n\n\nWorldpay.Within.dll\n - this contains the SDK code and public entry points.\n\n\nWorldpay.Within.Rpc.dll\n - the Thrift compiler-generated code to bridge to the core Go SDK.\n\n\nThrift.dll\n - Apache Thrift library. \n\n\nLogging Framework\n - whatever logging framework we're going to use.\n\n\n\n\nTo run a Worldpay Within application, the Thrift RPC code will need to be able to talk to an RPC Agent. The RPC Agent is a standalone application that manages the communication with remote third parties (for example, if you are creating a Consumer then the SDK code communicates with a local RPC Agent using the Thrift protocol, which then talks via HTTP to a remote RPC Agent, which then talks to a local Producer via the Thrift protocol).", 
            "title": ".NET"
        }, 
        {
            "location": "/dotnet/#net-software-development-kit-sdk", 
            "text": "The .NET implementation for the Worldpay Within IoT payment SDK. This SDK, or Software Development Kit, enables smart devices to discover each other, negogiate a price for services, make a payment (through the Worldpay Online Payment gateway) for services, and then consume services via a  trusted trigger . For more information see our documentation website  here .", 
            "title": ".NET Software Development Kit (SDK)"
        }, 
        {
            "location": "/dotnet/#prerequisites", 
            "text": "Before you get started, you should have the .NET 4.5 framework and Visual Studio 2017 (any edition) installed on your system. We've tested this wrapper with Visual 2017 Community Edition.  You should create an account with Worldpay Online so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.     Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/dotnet/#get-started", 
            "text": "The .NET Worldpay Within SDK provides a convenient entry point for application developers who wish to create applications using the Worldpay Within SDK.  Currently, there are no  NuGet  published libraries for the SDK. This issue is being tracked in  Issue #1 on GitHub .  For now, you will need to build the project yourself, by following these steps:   Clone or download the repository, e.g.  git clone git@github.com:WPTechInnovation/wpw-sdk-dotnet.git . See the  project homepage  on GitHub for more options.  Open up the solution file in Visual Studio 2017 (community edition or better).  Build the solution.  Note that you must be connected to the Internet for nuget dependencies to be downloaded:  ApacheThrift 0.10.0  Common.Logging 3.3.1  Common.Logging.Core 3.3.1    Download the RPC Agent binary build for your platform. The RPC Agents can be downloaded from  the wpw-sdk-iot-core  project.  To configure the .NET SDK to find the agent, download the agent in to a directory named bin and set a  WPW_HOME  environment variable to point to the directory above it. For example, if  rpc-agent-windows-386.exe  is installed in  C:\\users\\Andy\\wpw\\bin , then set  WPW_HOME  to  C:\\users\\Andy\\wpw .", 
            "title": "Get Started"
        }, 
        {
            "location": "/dotnet/#run-the-examples", 
            "text": "Once you've loaded the projects in to Visual Studio and built the project successfully (please note you can  report any problems or errors to us  on Github).  To run a sample app, run the  Worldpay.Within.Sample  project.  We'd recommend using your own test API keys for this. We've left our ones in the code, so that it \"just works\", but you won't be able to see the payments with our keys unless you change them. To do this, open  SimpleProducer.cs  and search for  MerchantServiceKey  in the  PSPConfig  declaration you can replace the existing MerchantServiceKey with your own value.   The sample application is a Windows console application. To make a simple payment, do the following:   Select option 1  Start Simple Producer . This will start a local RPC Agent and register a separate producer with it. Ths producer has a very simple service declaration.  Select option 3  Consume Purchase . This will start another RPC Agent and attempt to consume the first product of the first service it finds on the network. (This will most likely be your producer.)   The sample application produces lots of logging, you can control this by editing the  App.config  file in the root of the sample project directory.", 
            "title": "Run the examples"
        }, 
        {
            "location": "/dotnet/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.  If you used your own test API keys:\n1. Login to  Worldpay Online .\n1. You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .  If you've used Worldpay's own test API keys\n1. Login to  Worldpay Online .\n1. Got to  Settings   API keys  and get your test keys.\n1. Replace the keys in  SimpleProducer.cs .  Re-run the sample application and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "See the payments"
        }, 
        {
            "location": "/dotnet/#so-whats-happening", 
            "text": "You can see there are four phases:  Discover ,  Negotiate ,  Pay , and  Deliver . For more information, see  Worldpay Within .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/dotnet/#introduction-to-the-different-net-projects", 
            "text": "", 
            "title": "Introduction to the different .NET projects"
        }, 
        {
            "location": "/dotnet/#worldpaywithin", 
            "text": "This is the main .NET wrapper entry point assembly. The public API is contained within here, inside the  Worldpay.Within  package.  You can use Sandcastle to build the docs, however they will be published online at some point (see  Issue 2 ).", 
            "title": "Worldpay.Within"
        }, 
        {
            "location": "/dotnet/#worldpaywithinrpc", 
            "text": "This project contains nothing but the generated RPC wrappers for Thrift; you never edit code in here. This is a separate project because the style and organisation of the code generated by the Thrift compiler is pretty poor; this approach isolates this to a single project.  You can rebuild this code first deleting all the existing source files and their directories, to clear out any existing code that may have been moved or removed in a new version, then running the Thrift compiler:  thrift-0.10.0.exe -r -out %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\wrappers\\dotnet\\Worldpay.Within\\Worldpay.Within.Rpc --gen csharp:nullable,union %GOPATH%\\src\\innovation.worldpay.com\\worldpay-within-sdk\\rpc\\wpwithin.thrift   The  -r  is there just for safety, in case subdirectories are used in future for storing dependent Thrift IDL files.   Note that the above oaths assume that you have downloaded the  Worldpay Within main SDK project  in to a regular \"Go\" development struture. However, only the thrift interface files are actually required. You can grab those directly from here:  https://github.com/WPTechInnovation/worldpay-within-sdk/tree/master/rpc . There are two files needed:  wptypes.thrift  and  wpwithin.thrift , both files must be in the same directory.  They are not included within the .NET repository because they are centrally maintained and used to generate multiple language wrappers.  Be sure to refresh the project source tree in Visual Studio to ensure that any newly generated files are included in the project. If you fail to do this, expect compile errors for missing types to be thrown.", 
            "title": "Worldpay.Within.Rpc"
        }, 
        {
            "location": "/dotnet/#using-in-your-own-applications", 
            "text": "To use Worldpay Within, add the following DLLs to your project path:   Worldpay.Within.dll  - this contains the SDK code and public entry points.  Worldpay.Within.Rpc.dll  - the Thrift compiler-generated code to bridge to the core Go SDK.  Thrift.dll  - Apache Thrift library.   Logging Framework  - whatever logging framework we're going to use.   To run a Worldpay Within application, the Thrift RPC code will need to be able to talk to an RPC Agent. The RPC Agent is a standalone application that manages the communication with remote third parties (for example, if you are creating a Consumer then the SDK code communicates with a local RPC Agent using the Thrift protocol, which then talks via HTTP to a remote RPC Agent, which then talks to a local Producer via the Thrift protocol).", 
            "title": "Using in your own applications"
        }, 
        {
            "location": "/getting-started-with-go/", 
            "text": "Getting started\n\n\nTo code against the raw Go SDK, you will need to install Go and the Goland SDK. Alternatively, you can code against one of the multiple language wrappers, which give access to the SDK. \n\n\nThe Golang SDK communicates with these other languages using RPC calls (in both directions), and the wrappers in the background interface using Thrift. This is not exposed to you as a developer; you work with the Interface layer in your language of choice. We've got SDKs in the following languages:\n\n\n  \nJava (Javadoc)\n\n  \nPython 2.7 doc\n\n  \n.net / C# doc\n\n  \nNode.js doc\n\n\n\n\nThe binaries (if you don't want to build from source)\n\n\nPlease see the \nReleases\n section of GitHub for access to pre-built binaries of the RPC Agent and Dev Client apps. Both of the apps have been built for 32bit and 64bit architectures on Windows, MacOS, Linux and Linux (ARM).\n\n\nWhile the RPC Agent can be run from anywhere, it makes sense to add it to the directory of the application which will call it. The reason for this is that each application needs it own running instance of the RPC Agent and it can easily get confusing when there are multiple applications and agents deployed.\n\n\nPlease see the examples in both the Java and \nNode.JS\n wrappers. these examples currently hold binaries for MacOS x64. I suggest replacing that binary with an alternate build, if required.\n\n\nThe dev client can really be run from anywhere as it is not coupled with anything else.\n\n\nUsage\n\n\n\n\nRPC Agent \n./rpc-agent -configfile \nfilename\n/filename\n. Please see explanation of rpc-agent config file for further info.*   Dev Client \n./dev-client\n\n\n\n\nInstall - if you want to go from the Go source files!\n\n\n\n\nInstall Go command line\n\n\nSet up the environmental variables correctly; you only need to set \n$GOPATH\n, and that should be set as \n//\n, where is wherever you want the code, is \n/src/innovation.worldpay.com\n\n\nclone the repo to \n$GOPATH/src/innovation.worldpay.com\n\n\nGet the dependencies: \ngo get github.com/Sirupsen/logrus\n\n\nGet the dependencies: \ngo get github.com/gorilla/mux\n\n\nGet the dependencies: \ngo get github.com/nu7hatch/gouuid\n\n\nGet the dependencies: \ngo get git.apache.org/thrift.git/lib/go/thrift\n\n\n\n\nConfiguration file versus command line flags\n\n\nThe RPC client takes command line flags e.g. \n-port 9091\n but it can also take the flag \n-configfile 'conf.json'\n so you can specify the configuration in a config file. For example:\n\n\n!#go \n{\n    \nWorldpayWithinConfig\n: {\n        \nBufferSize\n : 100,\n        \nBuffered\n: false,\n        \nFramed\n: false,\n        \nHost\n: \n127.0.0.1\n,\n        \nLogfile\n: \nworldpayWithin.log\n,\n        \nLoglevel\n: \nwarn\n,\n        \nPort\n: 9081,\n        \nProtocol\n: \nbinary\n,\n        \nSecure\n: false\n    }\n}\n\n\n\n\n\nTutorial on running two example apps on one machine\n\n\n\n\nThe output of the log files for the orchestration of the flow.\n\n\n\n\nShowing the payment in online.worldpay.com.\n\n\n\n\nJava - 9090 - Producer\n\n\n\n\nNode.js - 9091 - consumer\n\n\n\n\n\n\nEach app needs to run on it's own instance of the RPC service, so run one on 9090 and the other on 9091\n\n\n\n\nSo we're running Java off of 9090 and running node.js off of 9091\n\n\nOpen two terminal windows\n\n\nConfigure the rpc agent in each terminal window to run on each of the ports. \n\n\nIn the producer window run the RPC on port 9090\n\n\nIn the consumer window run the RPC on port 9091\n\n\nConfigure the Java app to run on 9090 (run as the producer)\n\n\nConfigure the Node.js app to run on 9091 - in \ncreateClient\n in example code (run as the consumer)\n\n\nRun the Java producer app so we're broadcasting. The RPC agent broadcasting will continue to run in the background while the Java program has exited\n\n\nRun the Node.js consumer app immediately.\n\n\nThe \nDiscover\n, \nSelect\n, \nPay\n and \nRelease\n flows will all be triggered, as you can see above.", 
            "title": "Go"
        }, 
        {
            "location": "/getting-started-with-go/#getting-started", 
            "text": "To code against the raw Go SDK, you will need to install Go and the Goland SDK. Alternatively, you can code against one of the multiple language wrappers, which give access to the SDK.   The Golang SDK communicates with these other languages using RPC calls (in both directions), and the wrappers in the background interface using Thrift. This is not exposed to you as a developer; you work with the Interface layer in your language of choice. We've got SDKs in the following languages: \n   Java (Javadoc) \n   Python 2.7 doc \n   .net / C# doc \n   Node.js doc", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started-with-go/#the-binaries-if-you-dont-want-to-build-from-source", 
            "text": "Please see the  Releases  section of GitHub for access to pre-built binaries of the RPC Agent and Dev Client apps. Both of the apps have been built for 32bit and 64bit architectures on Windows, MacOS, Linux and Linux (ARM).  While the RPC Agent can be run from anywhere, it makes sense to add it to the directory of the application which will call it. The reason for this is that each application needs it own running instance of the RPC Agent and it can easily get confusing when there are multiple applications and agents deployed.  Please see the examples in both the Java and  Node.JS  wrappers. these examples currently hold binaries for MacOS x64. I suggest replacing that binary with an alternate build, if required.  The dev client can really be run from anywhere as it is not coupled with anything else.", 
            "title": "The binaries (if you don't want to build from source)"
        }, 
        {
            "location": "/getting-started-with-go/#usage", 
            "text": "RPC Agent  ./rpc-agent -configfile  filename /filename . Please see explanation of rpc-agent config file for further info.*   Dev Client  ./dev-client", 
            "title": "Usage"
        }, 
        {
            "location": "/getting-started-with-go/#install-if-you-want-to-go-from-the-go-source-files", 
            "text": "Install Go command line  Set up the environmental variables correctly; you only need to set  $GOPATH , and that should be set as  // , where is wherever you want the code, is  /src/innovation.worldpay.com  clone the repo to  $GOPATH/src/innovation.worldpay.com  Get the dependencies:  go get github.com/Sirupsen/logrus  Get the dependencies:  go get github.com/gorilla/mux  Get the dependencies:  go get github.com/nu7hatch/gouuid  Get the dependencies:  go get git.apache.org/thrift.git/lib/go/thrift", 
            "title": "Install - if you want to go from the Go source files!"
        }, 
        {
            "location": "/getting-started-with-go/#configuration-file-versus-command-line-flags", 
            "text": "The RPC client takes command line flags e.g.  -port 9091  but it can also take the flag  -configfile 'conf.json'  so you can specify the configuration in a config file. For example:  !#go \n{\n     WorldpayWithinConfig : {\n         BufferSize  : 100,\n         Buffered : false,\n         Framed : false,\n         Host :  127.0.0.1 ,\n         Logfile :  worldpayWithin.log ,\n         Loglevel :  warn ,\n         Port : 9081,\n         Protocol :  binary ,\n         Secure : false\n    }\n}", 
            "title": "Configuration file versus command line flags"
        }, 
        {
            "location": "/getting-started-with-go/#tutorial-on-running-two-example-apps-on-one-machine", 
            "text": "The output of the log files for the orchestration of the flow.   Showing the payment in online.worldpay.com.   Java - 9090 - Producer   Node.js - 9091 - consumer    Each app needs to run on it's own instance of the RPC service, so run one on 9090 and the other on 9091   So we're running Java off of 9090 and running node.js off of 9091  Open two terminal windows  Configure the rpc agent in each terminal window to run on each of the ports.   In the producer window run the RPC on port 9090  In the consumer window run the RPC on port 9091  Configure the Java app to run on 9090 (run as the producer)  Configure the Node.js app to run on 9091 - in  createClient  in example code (run as the consumer)  Run the Java producer app so we're broadcasting. The RPC agent broadcasting will continue to run in the background while the Java program has exited  Run the Node.js consumer app immediately.  The  Discover ,  Select ,  Pay  and  Release  flows will all be triggered, as you can see above.", 
            "title": "Tutorial on running two example apps on one machine"
        }, 
        {
            "location": "/nodejs/", 
            "text": "Node.js Software Development Kit (SDK)\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have \nNode.js\n installed on your system. We've tested this wrapper with version 6.11.1.\n\n\nYou should also have \nnpm\n installed on your machine too.\n\n\nYou should create an account with \nWorldpay Online\n so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK. \nWarning: Make sure you only use test API keys.\n\n\n\n\nGet started\n\n\nOnce you've got Node.js and npm.js, you should be good to go.\n\n\n\n\nClone or download \nthe repository\n.\n\n\nChange to the folder \ncd wpw-sdk-nodejs\n (if using linux / unix).\n\n\nRun the following command: \nnpm install thrift sleep\n.\n\n    Note: If you are using a different package manager than npm, please adjust the command accordingly.\n\n    (If there are issues about access rights, add sudo in front of the above command)\n\n\n\n\nRun the examples\n\n\nOnce you've got the repository and have changed to the right folder, you can start testing to see if it works. We'd recommend using your own test API keys for this. We've left our ones in the code, but you won't be able to see the payments with our keys.\n\n\n\n\nIn one terminal / cmd (or on one device) run: \nnode example-producer-callbacks.js\n.\n\n    (You can run \nnode example-producer.js\n but this does not recall the producer, once it times out)\n\n\nIn another terminal / cmd, (or on another device, on the same network) run: \nnode example-consumer.js\n.\n\n\nA payment should happen. If you see the serviceDeliveryToken returned within the producer terminal/cmd, you will know that the payment was complete.\n\n\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in the producer files.\n\n\nRe-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\n\n\nDebugging\n\n\nIf you get some odd error messages talking about a 'rpc-agent':\n\n\n\n\nTry typing the following command: 'ps -e | grep rpc' to get the pid(s) of rpc-agents that are running.\n\n\nThen do kill \n e.g. kill 13249234 to kill these processes.\n\n\nTry re-running the examples\n\n\n\n\nIf you're still having trouble, you can contact us at \n or reach out to us on our \nSlack channel\n. Alternatively, you can \nraise an issue in GitHub\n.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases; \nDiscover\n, \nNegotiation\n, \nPayment\n, and \nService delivery\n. For more information, see \nWorldpay Within\n.\n\n\nWhat IoT devices can I run this on?\n\n\nHopefully any. We've only tested this on RPi - Raspberry Pis at the moment, but we welcome experiments on all other kinds of devices! Note that they will need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checkout out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n. You can also reach out to us on our \nSlack channel\n.", 
            "title": "Node.js"
        }, 
        {
            "location": "/nodejs/#nodejs-software-development-kit-sdk", 
            "text": "", 
            "title": "Node.js Software Development Kit (SDK)"
        }, 
        {
            "location": "/nodejs/#prerequisites", 
            "text": "Before you get started, you should have  Node.js  installed on your system. We've tested this wrapper with version 6.11.1.  You should also have  npm  installed on your machine too.  You should create an account with  Worldpay Online  so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.  Warning: Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/nodejs/#get-started", 
            "text": "Once you've got Node.js and npm.js, you should be good to go.   Clone or download  the repository .  Change to the folder  cd wpw-sdk-nodejs  (if using linux / unix).  Run the following command:  npm install thrift sleep . \n    Note: If you are using a different package manager than npm, please adjust the command accordingly. \n    (If there are issues about access rights, add sudo in front of the above command)", 
            "title": "Get started"
        }, 
        {
            "location": "/nodejs/#run-the-examples", 
            "text": "Once you've got the repository and have changed to the right folder, you can start testing to see if it works. We'd recommend using your own test API keys for this. We've left our ones in the code, but you won't be able to see the payments with our keys.   In one terminal / cmd (or on one device) run:  node example-producer-callbacks.js . \n    (You can run  node example-producer.js  but this does not recall the producer, once it times out)  In another terminal / cmd, (or on another device, on the same network) run:  node example-consumer.js .  A payment should happen. If you see the serviceDeliveryToken returned within the producer terminal/cmd, you will know that the payment was complete.", 
            "title": "Run the examples"
        }, 
        {
            "location": "/nodejs/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.", 
            "title": "See the payments"
        }, 
        {
            "location": "/nodejs/#if-you-used-your-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .", 
            "title": "If you used your own test API keys"
        }, 
        {
            "location": "/nodejs/#if-youve-used-worldpays-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in the producer files.  Re-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "If you've used Worldpay's own test API keys"
        }, 
        {
            "location": "/nodejs/#debugging", 
            "text": "If you get some odd error messages talking about a 'rpc-agent':   Try typing the following command: 'ps -e | grep rpc' to get the pid(s) of rpc-agents that are running.  Then do kill   e.g. kill 13249234 to kill these processes.  Try re-running the examples   If you're still having trouble, you can contact us at   or reach out to us on our  Slack channel . Alternatively, you can  raise an issue in GitHub .", 
            "title": "Debugging"
        }, 
        {
            "location": "/nodejs/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases;  Discover ,  Negotiation ,  Payment , and  Service delivery . For more information, see  Worldpay Within .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/nodejs/#what-iot-devices-can-i-run-this-on", 
            "text": "Hopefully any. We've only tested this on RPi - Raspberry Pis at the moment, but we welcome experiments on all other kinds of devices! Note that they will need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...", 
            "title": "What IoT devices can I run this on?"
        }, 
        {
            "location": "/nodejs/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checkout out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  . You can also reach out to us on our  Slack channel .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/python27/", 
            "text": "Python Software Development Kit (SDK)\n\n\nThe Python implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a \ntrusted trigger\n. For more information see our documentation website here: \nWorldpay Within\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have Python installed on your system. We've built the SDK to work with version 2.7 and 3.\n\n\nYou should create an account with \nWorldpay Online\n so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.\n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet started\n\n\n\n\nDownload the \nrepository\n.\n\n\nDownload the latest version of Apache Thrift (currently 0.10.0).\n\n\nExtract the repository and change to the lib/py/ directory.\n\n\nRun the following command: sudo python setup.py install.\n\n\n\n\nRun the examples\n\n\nYou can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.\n\n\n\n\nIn the first window, run python runConsumerOWP.py\n\n\nIn the second window, run python runProducerOWP.py OR python runProducerCallbacksOWP.py\n\n\nThe two smart devices should communicate with each other and make a payment\n\n\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in the producer python files.\n\n\nRe-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\n\n\nDebugging\n\n\nIf you get some odd error messages talking about a 'rpc-agent':\n\n\n\n\nTry typing the following command: 'ps -e | grep rpc' to get the pid(s) of rpc-agents that are running.\n\n\nThen do kill \n e.g. kill 13249234 to kill these processes.\n\n\nTry re-running the examples\n\n\n\n\nIf you're still having trouble, you can contact us at \n or reach out to us on our \nSlack channel\n. Alternatively, you can \nraise an issue in GitHub\n.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases: \nDiscover\n, \nNegotiation\n, \nPayment\n, and \nService delivery\n. For more information, see \nWorldpay Within\n.\n\n\nWhat IoT devices can I run this on?\n\n\nHopefully any. We've only tested this on RPi - Raspberry Pis at the moment, but we welcome experiments on all other kinds of devices! Note that they will need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checkout out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n. You can also reach out to us on our \nSlack channel\n.", 
            "title": "Python 2.7"
        }, 
        {
            "location": "/python27/#python-software-development-kit-sdk", 
            "text": "The Python implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a  trusted trigger . For more information see our documentation website here:  Worldpay Within .", 
            "title": "Python Software Development Kit (SDK)"
        }, 
        {
            "location": "/python27/#prerequisites", 
            "text": "Before you get started, you should have Python installed on your system. We've built the SDK to work with version 2.7 and 3.  You should create an account with  Worldpay Online  so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.    Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/python27/#get-started", 
            "text": "Download the  repository .  Download the latest version of Apache Thrift (currently 0.10.0).  Extract the repository and change to the lib/py/ directory.  Run the following command: sudo python setup.py install.", 
            "title": "Get started"
        }, 
        {
            "location": "/python27/#run-the-examples", 
            "text": "You can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.   In the first window, run python runConsumerOWP.py  In the second window, run python runProducerOWP.py OR python runProducerCallbacksOWP.py  The two smart devices should communicate with each other and make a payment", 
            "title": "Run the examples"
        }, 
        {
            "location": "/python27/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.", 
            "title": "See the payments"
        }, 
        {
            "location": "/python27/#if-you-used-your-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .", 
            "title": "If you used your own test API keys"
        }, 
        {
            "location": "/python27/#if-youve-used-worldpays-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in the producer python files.  Re-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "If you've used Worldpay's own test API keys"
        }, 
        {
            "location": "/python27/#debugging", 
            "text": "If you get some odd error messages talking about a 'rpc-agent':   Try typing the following command: 'ps -e | grep rpc' to get the pid(s) of rpc-agents that are running.  Then do kill   e.g. kill 13249234 to kill these processes.  Try re-running the examples   If you're still having trouble, you can contact us at   or reach out to us on our  Slack channel . Alternatively, you can  raise an issue in GitHub .", 
            "title": "Debugging"
        }, 
        {
            "location": "/python27/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases:  Discover ,  Negotiation ,  Payment , and  Service delivery . For more information, see  Worldpay Within .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/python27/#what-iot-devices-can-i-run-this-on", 
            "text": "Hopefully any. We've only tested this on RPi - Raspberry Pis at the moment, but we welcome experiments on all other kinds of devices! Note that they will need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...", 
            "title": "What IoT devices can I run this on?"
        }, 
        {
            "location": "/python27/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checkout out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  . You can also reach out to us on our  Slack channel .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/python27/", 
            "text": "Python Software Development Kit (SDK)\n\n\nThe Python implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a \ntrusted trigger\n. For more information see our documentation website here: \nWorldpay Within\n.\n\n\nPrerequisites\n\n\n\n\nBefore you get started, you should have Python installed on your system. We've built the SDK to work with version 2.7 and 3.\n\n\nYou should create an account with \nWorldpay Online\n so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.\n\n\n\n\n\n\nWarning\n\n\nMake sure you only use test API keys.\n\n\n\n\nGet started\n\n\n\n\nDownload the \nrepository\n.\n\n\nDownload the latest version of Apache Thrift (currently 0.10.0).\n\n\nExtract the repository and change to the lib/py/ directory.\n\n\nRun the following command: sudo python setup.py install.\n\n\n\n\nRun the examples\n\n\nYou can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.\n\n\n\n\nIn the first window, run python runConsumerOWP.py\n\n\nIn the second window, run python runProducerOWP.py OR python runProducerCallbacksOWP.py\n\n\nThe two smart devices should communicate with each other and make a payment\n\n\n\n\nSee the payments\n\n\nOnce the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.\n\n\nIf you used your own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nYou'll see your dashboard. Scroll down and you should see the payment within your \nRecent Orders\n.\n\n\n\n\nIf you've used Worldpay's own test API keys\n\n\n\n\nLogin to \nWorldpay Online\n.\n\n\nGot to \nSettings \n API keys\n and get your test keys.\n\n\nReplace the keys in the producer python files.\n\n\nRe-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.\n\n\n\n\nDebugging\n\n\nIf you get some odd error messages talking about a 'rpc-agent':\n\n\n\n\nTry typing the following command: 'ps -e | grep rpc' to get the pid(s) of rpc-agents that are running.\n\n\nThen do kill \n e.g. kill 13249234 to kill these processes.\n\n\nTry re-running the examples\n\n\n\n\nIf you're still having trouble, you can contact us at \n or reach out to us on our \nSlack channel\n. Alternatively, you can \nraise an issue in GitHub\n.\n\n\nSo what's happening?\n\n\n\n\nThe Worldpay Within Flows sequence diagram\n\n\nYou can see there are four phases: \nDiscover\n, \nNegotiation\n, \nPayment\n, and \nService delivery\n. For more information, see \nWorldpay Within\n.\n\n\nWhat IoT devices can I run this on?\n\n\nHopefully any. We've only tested this on RPi - Raspberry Pis at the moment, but we welcome experiments on all other kinds of devices! Note that they will need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...\n\n\nWant to contribute?\n\n\nIf you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checkout out the \nInternal Structure of Worldpay Within\n and \nSample Service Messaging\n pages if you want to learn more about how Worldpay Within works.\n\n\nYou can also \nraise an issue in GitHub\n, or contact us directly at \n. You can also reach out to us on our \nSlack channel\n.", 
            "title": "Java"
        }, 
        {
            "location": "/python27/#python-software-development-kit-sdk", 
            "text": "The Python implementation for the Worldpay Within IoT payment SDK. This SDK enables smart devices to discover each other, negotiate a price for services, make a payment (through Worldpay) for services, and then consume services via a  trusted trigger . For more information see our documentation website here:  Worldpay Within .", 
            "title": "Python Software Development Kit (SDK)"
        }, 
        {
            "location": "/python27/#prerequisites", 
            "text": "Before you get started, you should have Python installed on your system. We've built the SDK to work with version 2.7 and 3.  You should create an account with  Worldpay Online  so that you're able to generate your own test API key. You'll replace the Worldpay test keys with your own in the SDK.    Warning  Make sure you only use test API keys.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/python27/#get-started", 
            "text": "Download the  repository .  Download the latest version of Apache Thrift (currently 0.10.0).  Extract the repository and change to the lib/py/ directory.  Run the following command: sudo python setup.py install.", 
            "title": "Get started"
        }, 
        {
            "location": "/python27/#run-the-examples", 
            "text": "You can try the examples by running the examples in two different console windows. Or, if you're installing on two separate devices, they must be one the same network that allows UDP broadcast traffic. Make sure you're using rhw Online Worldpay (OWP) files rather than the Worldpay Total (WT) ones.   In the first window, run python runConsumerOWP.py  In the second window, run python runProducerOWP.py OR python runProducerCallbacksOWP.py  The two smart devices should communicate with each other and make a payment", 
            "title": "Run the examples"
        }, 
        {
            "location": "/python27/#see-the-payments", 
            "text": "Once the devices have successfully communicated with each other to make a payment, you'll want to check to make sure that your devices are successfully making and receiving payments.", 
            "title": "See the payments"
        }, 
        {
            "location": "/python27/#if-you-used-your-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  You'll see your dashboard. Scroll down and you should see the payment within your  Recent Orders .", 
            "title": "If you used your own test API keys"
        }, 
        {
            "location": "/python27/#if-youve-used-worldpays-own-test-api-keys", 
            "text": "Login to  Worldpay Online .  Got to  Settings   API keys  and get your test keys.  Replace the keys in the producer python files.  Re-run the examples and you should see the payments coming through on the Worldpay Online payments dashboard.", 
            "title": "If you've used Worldpay's own test API keys"
        }, 
        {
            "location": "/python27/#debugging", 
            "text": "If you get some odd error messages talking about a 'rpc-agent':   Try typing the following command: 'ps -e | grep rpc' to get the pid(s) of rpc-agents that are running.  Then do kill   e.g. kill 13249234 to kill these processes.  Try re-running the examples   If you're still having trouble, you can contact us at   or reach out to us on our  Slack channel . Alternatively, you can  raise an issue in GitHub .", 
            "title": "Debugging"
        }, 
        {
            "location": "/python27/#so-whats-happening", 
            "text": "The Worldpay Within Flows sequence diagram  You can see there are four phases:  Discover ,  Negotiation ,  Payment , and  Service delivery . For more information, see  Worldpay Within .", 
            "title": "So what's happening?"
        }, 
        {
            "location": "/python27/#what-iot-devices-can-i-run-this-on", 
            "text": "Hopefully any. We've only tested this on RPi - Raspberry Pis at the moment, but we welcome experiments on all other kinds of devices! Note that they will need to be on the same network - and that network should allow for UDP broadcast traffic. Most mobile hotspots allow this; a lot of corporate networks do not...", 
            "title": "What IoT devices can I run this on?"
        }, 
        {
            "location": "/python27/#want-to-contribute", 
            "text": "If you want to contribute, clone the repository and create a branch. Once you've made your changes, create a pull request. We'll review your code, and if accepted it will be merged into the code base. It's worth checkout out the  Internal Structure of Worldpay Within  and  Sample Service Messaging  pages if you want to learn more about how Worldpay Within works.  You can also  raise an issue in GitHub , or contact us directly at  . You can also reach out to us on our  Slack channel .", 
            "title": "Want to contribute?"
        }, 
        {
            "location": "/hackathons/", 
            "text": "Payments \n IoT Hackathons\n\n\nComing soon - November 2017 - Romania hackathon\n\n\nIn November, we're hosting our latest IoT and Payments hackathon, based on Worldpay Within. We're delighted to be hosting this in the beautiful Bucharest, Romania. More details will be coming soon. \n\n\nThis time it's all about Worldpay Within on Raspberry Pis, with the theme focusing on smart home, smart cities and smart living. We've got some really exciting sponsors, which we will also be announcing soon. We've also got really awesome cash prizes for the 3 winning teams. \n\n\nYou'll be able to register for the event soon. If you're super keen and want to hear further ahead of that time, email us at \n.\n\n\nFebruary 2017 - Atlanta hackathon, featuring Worldpay Within\n\n\nWorldpay US was a sponsor of the ATDC Fintech Hackathon, a weekend in which 18 teams competed in a battle to demonstrate how well they integrated either Worldpay or TSYS APIs into their own applications.\n\n\nFor more information, see \nAtlanta hackathon page\n.\n\n\nSeptember 2016 - Our Inaugral Payments \n Iot hackathon\n\n\nWorldpay's Technology Innovation team held their first Internet of Things (IoT) hackathon at the Impact Hub in Westminster, London. It was the first time they'd hosted a hackathon and it was attended by over 80 technologists and experienced coders, who came together to explore use-cases for exciting mobile payments and new IoT open-source technology.\n\n\nOver the weekend, the participants brought to life a range of innovative concepts from building a payment system following a natural disaster, to payments apps for the sharing economy.\n\n\nSee our press releases \nhere\n and \nhere\n.\n\n\nWatch the video\n\n\nWe recorded what happened at the September 2016 hackathon. You'll hear from some of the delegates, judges, mentors, sponsors and organisers, and see some of the cool tech that was brought and awesome demos that were built that weekend.", 
            "title": "Hackathons"
        }, 
        {
            "location": "/hackathons/#payments-iot-hackathons", 
            "text": "", 
            "title": "Payments &amp; IoT Hackathons"
        }, 
        {
            "location": "/hackathons/#coming-soon-november-2017-romania-hackathon", 
            "text": "In November, we're hosting our latest IoT and Payments hackathon, based on Worldpay Within. We're delighted to be hosting this in the beautiful Bucharest, Romania. More details will be coming soon.   This time it's all about Worldpay Within on Raspberry Pis, with the theme focusing on smart home, smart cities and smart living. We've got some really exciting sponsors, which we will also be announcing soon. We've also got really awesome cash prizes for the 3 winning teams.   You'll be able to register for the event soon. If you're super keen and want to hear further ahead of that time, email us at  .", 
            "title": "Coming soon - November 2017 - Romania hackathon"
        }, 
        {
            "location": "/hackathons/#february-2017-atlanta-hackathon-featuring-worldpay-within", 
            "text": "Worldpay US was a sponsor of the ATDC Fintech Hackathon, a weekend in which 18 teams competed in a battle to demonstrate how well they integrated either Worldpay or TSYS APIs into their own applications.  For more information, see  Atlanta hackathon page .", 
            "title": "February 2017 - Atlanta hackathon, featuring Worldpay Within"
        }, 
        {
            "location": "/hackathons/#september-2016-our-inaugral-payments-iot-hackathon", 
            "text": "Worldpay's Technology Innovation team held their first Internet of Things (IoT) hackathon at the Impact Hub in Westminster, London. It was the first time they'd hosted a hackathon and it was attended by over 80 technologists and experienced coders, who came together to explore use-cases for exciting mobile payments and new IoT open-source technology.  Over the weekend, the participants brought to life a range of innovative concepts from building a payment system following a natural disaster, to payments apps for the sharing economy.  See our press releases  here  and  here .", 
            "title": "September 2016 - Our Inaugral Payments &amp; Iot hackathon"
        }, 
        {
            "location": "/hackathons/#watch-the-video", 
            "text": "We recorded what happened at the September 2016 hackathon. You'll hear from some of the delegates, judges, mentors, sponsors and organisers, and see some of the cool tech that was brought and awesome demos that were built that weekend.", 
            "title": "Watch the video"
        }, 
        {
            "location": "/how-it-works/", 
            "text": "1. Understand the flows\n\n\nBefore you start it's worth familiarising yourself with how Worldpay Within works. We recommend following the pre-established flows in the order they are presented for each Thing (Machine A and Machine B). If you stray from the flows, we cannot guarantee that the SDKs will work.\n\n\nThe devices are not synchronised by the SDK, so you'll need to ensure that the SDKs call the Worldpay Within API in the correct order. If you follow the steps below, then the outcome should be as expected.\n\n\nWorldpay Within flow\n\n\nThe Consumer (Shopper) flow\n\n\n\n\nThe consumer flow.\n\nThe consumer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.\n\n\n\n\n\n\n\n\nStep in Flow\n\n\nWhat it does\n\n\n\n\n\n\n\n\n\n\n1. `SETUP\n\n\nSets up the device\n\n\n\n\n\n\n2. DEVICE DISCOVERY\n\n\nDiscover devices that are broadcasting messages\n\n\n\n\n\n\n3. (CHOOSE MESSAGE)\n\n\nChoose the message, then use that information in the following steps\n\n\n\n\n\n\n4. INIT CONSUMER\n\n\nInitialises the device as a consumer\n\n\n\n\n\n\n5. REQUEST SERVICES\n\n\nRequest service messages from the device that is broadcasting, which lists what services it's offering\n\n\n\n\n\n\n6. GET SERVICE PRICES\n\n\nGets the prices for the service you are interested in\n\n\n\n\n\n\n7. SELECT SERVICE\n\n\nSelects the service the device wants to consume\n\n\n\n\n\n\n8. MAKE PAYMENT\n\n\nMakes a payment for the chosen service\n\n\n\n\n\n\n9. BEGIN SERVICE DELIVERY\n\n\nStarts the process / flow to consume the service based on the service token received.\n\n\n\n\n\n\n10. STOP SERVICE DELIVERY\n\n\nCall to tell the other thing that it has completed it's consumption of the service\n\n\n\n\n\n\n\n\nThe Producer (Merchant) flow\n\n\n\n\nThe producer flow.\n\nThe producer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.\n\n\n\n\n\n\n\n\nStep in Flow\n\n\nWhat it does\n\n\n\n\n\n\n\n\n\n\n1. SETUP\n\n\nSets up the device\n\n\n\n\n\n\n2A. ADD SERVICE\n\n\nAdds a service to the producer\n\n\n\n\n\n\n2B. REMOVE SERVICE\n\n\nRemoves a service from the producer\n\n\n\n\n\n\n3. INIT PRODUCER\n\n\nInitialises the producer\n\n\n\n\n\n\n4A. START BROADCAST\n\n\nStarts the producer broadcasting its service message\n\n\n\n\n\n\n4B. STOP BROADCAST\n\n\nStops the producer from broadcasting its service message\n\n\n\n\n\n\n\n\n2. Choose your SDK\n\n\nFor the alpha release, we decided to go with four different wrappers. The documentation and API specification can be found here:\n\n\nGo to Java (Javadoc)\n \nGo to Python 2.7 doc\n \nGo to .net / C# doc\n \nGo to Node.js doc", 
            "title": "How it works"
        }, 
        {
            "location": "/how-it-works/#146-understand-the-flows", 
            "text": "Before you start it's worth familiarising yourself with how Worldpay Within works. We recommend following the pre-established flows in the order they are presented for each Thing (Machine A and Machine B). If you stray from the flows, we cannot guarantee that the SDKs will work.  The devices are not synchronised by the SDK, so you'll need to ensure that the SDKs call the Worldpay Within API in the correct order. If you follow the steps below, then the outcome should be as expected.", 
            "title": "1. Understand the flows"
        }, 
        {
            "location": "/how-it-works/#worldpay-within-flow", 
            "text": "", 
            "title": "Worldpay Within flow"
        }, 
        {
            "location": "/how-it-works/#the-consumer-shopper-flow", 
            "text": "The consumer flow. \nThe consumer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.     Step in Flow  What it does      1. `SETUP  Sets up the device    2. DEVICE DISCOVERY  Discover devices that are broadcasting messages    3. (CHOOSE MESSAGE)  Choose the message, then use that information in the following steps    4. INIT CONSUMER  Initialises the device as a consumer    5. REQUEST SERVICES  Request service messages from the device that is broadcasting, which lists what services it's offering    6. GET SERVICE PRICES  Gets the prices for the service you are interested in    7. SELECT SERVICE  Selects the service the device wants to consume    8. MAKE PAYMENT  Makes a payment for the chosen service    9. BEGIN SERVICE DELIVERY  Starts the process / flow to consume the service based on the service token received.    10. STOP SERVICE DELIVERY  Call to tell the other thing that it has completed it's consumption of the service", 
            "title": "The Consumer (Shopper) flow"
        }, 
        {
            "location": "/how-it-works/#the-producer-merchant-flow", 
            "text": "The producer flow. \nThe producer device should follow this flow. These steps should map to the interface either in Go, or in your chosen SDK wrapper.     Step in Flow  What it does      1. SETUP  Sets up the device    2A. ADD SERVICE  Adds a service to the producer    2B. REMOVE SERVICE  Removes a service from the producer    3. INIT PRODUCER  Initialises the producer    4A. START BROADCAST  Starts the producer broadcasting its service message    4B. STOP BROADCAST  Stops the producer from broadcasting its service message", 
            "title": "The Producer (Merchant) flow"
        }, 
        {
            "location": "/how-it-works/#246-choose-your-sdk", 
            "text": "For the alpha release, we decided to go with four different wrappers. The documentation and API specification can be found here:  Go to Java (Javadoc)   Go to Python 2.7 doc   Go to .net / C# doc   Go to Node.js doc", 
            "title": "2. Choose your SDK"
        }, 
        {
            "location": "/architecture/", 
            "text": "Quick intro\n\n\nTo complement the architecture, we have released the Worldpay Within SDK. The intention for of the SDK is to encapsulate implementation and therefore assist third party vendors and developers in integration into their Internet of Things (IoT) solutions.\n\n\nThe core of the SDK is developed in the Go programming language with wrappers created for Java, Node.JS, Python and .net(C#). Service delivery and broadcast have been implemented using TCP/IP networking.\n\n\nFor more information about the low level service messaging, see click \nhere\n.\n\n\nArchitecture Overview\n\n\nIn the IoT, each Thing will perform the function it is designed for be it acting as a sensor, a controller or both. In order for the Thing to be able to make and receive payments for services they can provide to other Things, they need to add the payments functionality contained in Worldpay Within.\n\n\n\n\nFigure 1. Worldpay Within Pluggable agent.\n\n\nThings in the IoT will be implemented on dedicated low cost processor systems. The Thing and Worldpay Within must co-exist and operate on the resources provided by these devices, as demonstrated in Figure 2.\n\n\n\n\nFigure 2. Worldpay Within Logical Overview.\n\n\nIn order to make and receive payments in the IoT, a Thing must be able to perform the roles of consumer (shopper), to make a payment for services, and the producer (merchant) to receive a payment for provision of services. In the Worldpay Within IoT architecture, the \u201cconsumer\u201d pays for services by supporting Host Card Emulation (HCE). The \u201cmerchant\u201d or \"producer\" receives payments for services by supporting Host Terminal Emulation (HTE). Worldpay Within contains both an HCE Brain \n HTE Brain functionalities, ensuring a Thing can both consume and supply services. These services are provided through a series of public APIs, described within this document.\n\n\nHCE and HTE require the secure storage and use of the credentials during the payments process. This requires the use of secure processing within the Thing in a \u201cSecure Execution Environment\u201d.\n\n\nFor HCE Things, these credentials include the details of the \u201ccard\u201d which the payment will be made from. For HTE Things, these credentials include the details the Merchant requires to perform transactions with Worldpay.\n\n\nAs well as the provision of the payment for the services, Worldpay Within provides for the generation and validation of secure service tokens, which allow for services to be consumed in part or together, but separately from the payments functionality.\n\n\nWorldpay Within IoT Service Architecture\n\n\nThe provision of a service within the Worldpay IoT system is performed in 4 phases, as shown in Figure 4, these being: Service Discovery, Service Negotiation, Payment, and Service Delivery. Each of these phases are described in the following sections.\n\n\n\n\nFigure 4. The 4 phases of Worldpay Within.\n\n\nService Discovery\n\n\nEach Thing that offers services, the service \u2018supplier\u2019 shall broadcast it\u2019s list of available services, as shown in Figure 4 below. When a potential \u2018consumer\u2019 of the service connects with \u2018supplier\u2019 it can request details of the services offered.\n\n\nProviding a suitable service is discovered, the consumer then requests the service from the supplier, and price negotiations can begin.\n\n\n\n\nFigure 5. IoT Service discovery.\n\n\nService Discovery APIs\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nbroadcast\n\n\nserver_UUID\n\n\nAdvertising services and identifying the sender\n\n\n\n\n\n\nrequest services\n\n\nnone\n\n\nRequest a list of all services\n\n\n\n\n\n\nservices_response\n\n\nlist of services\n, \nserver_UUID\n\n\nProvide client with a list of possible services that the sender can provide\n\n\n\n\n\n\n#### Service discovery messages\n\n\n\n\n\n\n\n\n\n\n\n\nA broadcast message that includes Thing B\u2019s UUID is sent.\n\n\nUpon receiving the message Thing A connects to Thing B and requests the list of available services.\n\n\nThing B responds with a list identifying the services available.\n\n\nService Negotiation\n\n\nOnce a suitable service has been discovered, there will be a price negotiation. The provider may offer the same service at different rates depending on the number of units of service to be purchased. The process is outlined in Figure 5. The outcome of the process is an agreement to purchase an amount of service and a total price for the service to be provided. The service provider can then request payment for the agreed service and price.\n\n\n\n\nFigure 6. IoT Service Negotiation.\n\n\nService Negotiation APIs\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nprice_request\n\n\nservice_id\n\n\nRequest a list of all prices for a given service.\n\n\n\n\n\n\nprice_response\n\n\nserver_UUID\n, list of prices, (\nservice_id\n, \nprice_id\n, \nprice_per_unit\n, \nunit_ID\n, \nunit_description\n, \nprice_description\n)\n\n\nProvide the client with a list of prices for a given service. A price object contains the per unit price.\n\n\n\n\n\n\nprice_select\n\n\nservice_id\n, \nprice_id\n, \nnumber_of_units\n, \nclient_UUID\n\n\nSelect a price with \nprice_id\n, for \nservice_id\n for a number of units.\n\n\n\n\n\n\nprice_select_response\n\n\nprice_id\n, \nnumber_of_units\n, \ntotal_price\n, \nserver_UUID\n, \nclient_UUID\n, \npayment_ref_ID\n, \nMerchant_Client_key\n\n\nCommunicate the expected total price to the client.\n\n\n\n\n\n\n\n\nService negotiation messages\n\n\nA price request is sent containing the selected service_id.\n\n\nThe response from Thing B contains a list of price items; each item should contain a \nprice_id\n, per unit price, \nunit_ID\n and description fields of both the unit and the price.\n\n\nThing A then selects an appropriate \nprice_id\n by sending a request with its \nclient_UUID\n, the selected \nservice_id\n, the \nprice_id\n, and the number of items required.\n\n\nIf the number of items falls within the correct number of items for the price selected, then Thing B responds with a price select response containing the \nservice_id\n, \nprice_id\n, the total price, the \nservice_UUID\n and a reference for the payment and its Merchant Client key. Otherwise Thing B shall return the number of units it can supply along with the correct price, and additional details required to initiate the payment.\n\n\nPayment\n\n\nThe payment process with Worldpay is a two stage process, split between the consumer and merchant Things involved in the transaction, these stages are:\n\n\n\n\n\n\nClient Token Request, and\n\n\n\n\n\n\nPayment Authorisation Request. (Also known as Order Request)\n\n\n\n\n\n\nDuring the first stage, the consumer sends Worldpay their payment credentials and the merchants Client Key. We return a Client Token, which the consumer passes to the Merchant. This allows the merchant to perform the payment authorisation request with Worldpay by providing the Client Token and transaction details.\n\n\nThis payment process ensures that the consumer does not pass their payment credentials to the merchant, only to Worldpay.\n\n\nClient token request\n\n\nThe first step in the payment process is when Thing A receives the \nMerchant_Client_Key\n from Thing B. Thing B passes their public Client Key to Thing A as part of the \nprice_select_response\n during the Service Negotiation phase. Upon receiving the Client Key from Thing B, Thing A connects with Worldpay to request the client token from us. This request includes Thing A\u2019s payment credentials: Card PAN, expiry, and the \nclient_key\n of Thing B. Worldpay will respond with a message that includes a \nclient_token\n. This is shown in Figure 7.\n\n\n\n\nFigure 7. IoT Payment process - client token request.\n\n\nClient token request APIs\n\n\nThing A to Worldpay client token request\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nclient_token_request\n\n\nPayment_method\n, \nreusable_flag\n, \nMerchant_client_key\n, \nPayment_method\n (\nname\n, \nPAN\n, \nexpiryMonth\n, \nexpiryYear\n, \ntype\n)\n\n\nRequest a client token from Worldpay, whilst providing us with the payment credentials.\n\n\n\n\n\n\nclient_token_response\n\n\nclient_token\n, \nreusable_flag\n, \npayment_method_response\n (\ntype\n, \nname\n, \nexpiryMonth\n, \nexpiryYear\n, \ncard\\_type\n, \ncard\\_scheme\\_type\n, \ncard\\_scheme\\_name\n, \nmasked\\_card\\_number\n, \ncard\\_product\\_type\\_description\\_non\\_contactless\n, \ncard\\_product\\_type\\_description\\_contactless\n, \ncard\\_issuer\n, \ncountry\\_code\n, \ncard\\_class\n, \npre-paid\n)\n\n\nResponse from Worldpay containing the client_token.\n\n\n\n\n\n\nPayment_request\n\n\nclient_token\n, \nclient_UUID\n, \npayment_ref_ID\n\n\nThe \nclient_token\n is passed to Thing B to allow the 2\nnd\n part of the transaction process to take place.\n\n\n\n\n\n\n\n\nThing A will connect to Worldpay using Transport Layer Security (TLS). It will then request a \nclient_token\n by securely (see 2.2.1) sending a JSON message containing the \npaymentMethod\n, its payment credentials (PAN, expiry) to us, along with the \nclient_ key\n from Thing B. In addition a flag indicating if the client details can be used in future is sent, for IoT this should always be set \u2018reusable\u2019:\u2019false\u2019 in order to force generation of a new client token for each transaction.\n\n\nA successful response will be an HTTP \nPOST\n response containing fields: \nclient_token\n, \nreusable_flag\n and the \npayment_method_response\n. Once received, the \nclient_token\n shall be passed to Thing B.\n\n\nA sample request is shown in Appendix B: Sample Service Messaging.\n\n\nSee \nAPI keys\n for documentation for \nclient_token_request\n and \nclient_token_repsonse\n APIs data descriptions.\n\n\nPayment authorisation request\n\n\nThing B will process the order and request the payment from Worldpay providing its service key, \nclient_token\n, transaction currency and payment amount. This is transmitted to Worldpay over TLS. After successful processing the payment, Worldpay will provide a payment response. Thing B shall then generate a service token, which Thing A may use in future to obtain the services that the payment has been made for. This is shown in Figure 7.\n\n\n\n\nFigure 8. Payment Authorisation Request.\n\n\nPayment authorisation request APIs\n\n\nThing B to Worldpay payment authorisation request\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\norder_request\n\n\nclient_service_key\n, \nclient_token\n, \ncurrency_code\n, \namount\n, \norder_description\n, \ncustomer_order_code\n\n\nRequest payment from Worldpay.\n\n\n\n\n\n\norder_response\n\n\norder_code\n, \nclient_token\n, \norder_description\n, \namount\n, \ncurrency_code\n, \npayment_status\n, \ncustomer_order_code\n, \nenvironment\n, \nrisk_score\n, \npayment_response\n (\ntype\n, \nname\n, \nexpiryMonth\n, \nexpiryYear\n, \ncard\\_type\n, \ncard\\_scheme\\_type\n, \ncard\\_scheme\\_name\n, \nmasked\\_card\\_number\n, \ncard\\_product\\_type\\_description\\_non\\_contactless\n, \ncard\\_product\\_type\\_description\\_contactless\n, \ncard\\_issuer\n, \ncountry\\_code\n, \ncard\\_class\n, \npre-paid\n)\n\n\nPayment response indicating a successful transaction on the Worldpay platform.\n\n\n\n\n\n\n\n\nThing B will assemble a message to be posted to Worldpay that contains the client token, Service key, the amount, currency and transaction description. We will then perform an authorisation using the payment credentials identified by the \nclient_token\n. A successful authorisation will result in a \npayment_status\n of SUCCESS being returned to Thing B.\n\n\nThing B to Thing A service token\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\npayment_request_response\n\n\nservice_delivery_token\n, \nserver_UUID\n, \nclient_UUID\n, \ntotal_paid\n\n\nservice_delivery_token\n is passed to ThingB.\n\n\n\n\n\n\n\n\nThing B shall then generate a cryptographically secure \nservice_delivery_token\n, which can be used by Thing A to request provision of services from Thing B.\n\n\nService Delivery\n\n\nOnce the payment has been made, Thing B shall return to broadcasting its available services. Thing A will now be able to consume the service from Thing B by providing the \nservice_delivery_token\n. The service delivery may be in a single step, or over time. An overview of service delivery is shown in Figure 8.\n\n\n\n\nFigure 8. Service delivery.\n\n\nOnce in possession of a service_token, Thing A may then request the service be provided. The service could be consumed in one session, or in several sessions over time, depending on the nature of the service and number of units purchased. Thing A may repeatedly send service delivery requests until Thing B indicates that the service has been delivered.\n\n\nService Delivery APIs\n\n\n\n\n\n\n\n\nKey\n\n\nParameters\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\npayment_request_response\n\n\nservice_delivery_token\n, \nserver_UUID\n, \nclient_UUID\n, \ntotal_paid\n\n\nservice_delivery_token\n is passed to ThingB.\n\n\n\n\n\n\nbroadcast\n\n\nserver_UUID\n\n\nAdvertising services and identifying the sender.\n\n\n\n\n\n\ndelivery_begin_request\n\n\nservice_delivery_token\n, \nclient_UUID\n, \nnumber_of_units_to_supply\n\n\nRequest the service item, with the \nservice_delivery_token\n providing right to receive the service, and amount of service to be supplied.\n\n\n\n\n\n\ndelivery_begin_response\n\n\nserver_UUID\n, \nservice_delivery_token\n, \nclient_UUID\n, \nnumber_of_units_to_be_supplied\n\n\nResponse for the service delivery. Confirmation of number of service units to be supplied (Allowing for less units than requested).\n\n\n\n\n\n\ndelivery_end\n\n\nclient_UUID\n, \nnumber_of_units_received\n\n\nConfirmation of service received.\n\n\n\n\n\n\ndelivery_end_response\n\n\nserver_UUID\n, \nservice_delivery_token\n, \nclient_UUID\n, \nnumber_of_units_just_supplied\n, \nnumber_of_units_remaining\n\n\nService end indicating outstanding service credits and token for subsequent delivery.\n\n\n\n\n\n\n\n\nThing A sends a message with the \nservice_delivery_token\n to Thing B, along with the amount of service it wishes to consume. The response shall confirm the amount of service units that Thing B can supply to Thing A at that time. Once the service has been delivered, Thing A shall confirm the amount of service units it has received, with Thing B responding, stating the number of units still remaining to Thing A, if any.\n\n\nUseful terms\n\n\nA few useful terms we're making quite a lot of use of, and if you are new to the world of payments these may be unfamiliar to you!\n\n\n\n\n\n\n\n\nTerm\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nAPI\n\n\nApplication Programming Interface\n\n\n\n\n\n\nWorldpay\n\n\nWorldpay Open Payment API, \nhttps://online.worldpay.com/\n\n\n\n\n\n\nHCE\n\n\nHost Card Emulation\n\n\n\n\n\n\nHTE\n\n\nHost Terminal Emulation\n\n\n\n\n\n\nHTTPS\n\n\nHyperText Transfer Protocol Secure\n\n\n\n\n\n\nIoT\n\n\nInternet of Things\n\n\n\n\n\n\nP2PE\n\n\nPoint to Point Encryption\n\n\n\n\n\n\nTLS\n\n\nTransport Layer Security\n\n\n\n\n\n\nUUID\n\n\nUniversally Unique Identifier\n\n\n\n\n\n\nRPC\n\n\nRemote Procedure Call", 
            "title": "Architecure"
        }, 
        {
            "location": "/architecture/#quick-intro", 
            "text": "To complement the architecture, we have released the Worldpay Within SDK. The intention for of the SDK is to encapsulate implementation and therefore assist third party vendors and developers in integration into their Internet of Things (IoT) solutions.  The core of the SDK is developed in the Go programming language with wrappers created for Java, Node.JS, Python and .net(C#). Service delivery and broadcast have been implemented using TCP/IP networking.  For more information about the low level service messaging, see click  here .", 
            "title": "Quick intro"
        }, 
        {
            "location": "/architecture/#architecture-overview", 
            "text": "In the IoT, each Thing will perform the function it is designed for be it acting as a sensor, a controller or both. In order for the Thing to be able to make and receive payments for services they can provide to other Things, they need to add the payments functionality contained in Worldpay Within.   Figure 1. Worldpay Within Pluggable agent.  Things in the IoT will be implemented on dedicated low cost processor systems. The Thing and Worldpay Within must co-exist and operate on the resources provided by these devices, as demonstrated in Figure 2.   Figure 2. Worldpay Within Logical Overview.  In order to make and receive payments in the IoT, a Thing must be able to perform the roles of consumer (shopper), to make a payment for services, and the producer (merchant) to receive a payment for provision of services. In the Worldpay Within IoT architecture, the \u201cconsumer\u201d pays for services by supporting Host Card Emulation (HCE). The \u201cmerchant\u201d or \"producer\" receives payments for services by supporting Host Terminal Emulation (HTE). Worldpay Within contains both an HCE Brain   HTE Brain functionalities, ensuring a Thing can both consume and supply services. These services are provided through a series of public APIs, described within this document.  HCE and HTE require the secure storage and use of the credentials during the payments process. This requires the use of secure processing within the Thing in a \u201cSecure Execution Environment\u201d.  For HCE Things, these credentials include the details of the \u201ccard\u201d which the payment will be made from. For HTE Things, these credentials include the details the Merchant requires to perform transactions with Worldpay.  As well as the provision of the payment for the services, Worldpay Within provides for the generation and validation of secure service tokens, which allow for services to be consumed in part or together, but separately from the payments functionality.", 
            "title": "Architecture Overview"
        }, 
        {
            "location": "/architecture/#worldpay-within-iot-service-architecture", 
            "text": "The provision of a service within the Worldpay IoT system is performed in 4 phases, as shown in Figure 4, these being: Service Discovery, Service Negotiation, Payment, and Service Delivery. Each of these phases are described in the following sections.   Figure 4. The 4 phases of Worldpay Within.", 
            "title": "Worldpay Within IoT Service Architecture"
        }, 
        {
            "location": "/architecture/#service-discovery", 
            "text": "Each Thing that offers services, the service \u2018supplier\u2019 shall broadcast it\u2019s list of available services, as shown in Figure 4 below. When a potential \u2018consumer\u2019 of the service connects with \u2018supplier\u2019 it can request details of the services offered.  Providing a suitable service is discovered, the consumer then requests the service from the supplier, and price negotiations can begin.   Figure 5. IoT Service discovery.", 
            "title": "Service Discovery"
        }, 
        {
            "location": "/architecture/#service-discovery-apis", 
            "text": "Key  Parameters  Purpose      broadcast  server_UUID  Advertising services and identifying the sender    request services  none  Request a list of all services    services_response  list of services ,  server_UUID  Provide client with a list of possible services that the sender can provide    #### Service discovery messages       A broadcast message that includes Thing B\u2019s UUID is sent.  Upon receiving the message Thing A connects to Thing B and requests the list of available services.  Thing B responds with a list identifying the services available.", 
            "title": "Service Discovery APIs"
        }, 
        {
            "location": "/architecture/#service-negotiation", 
            "text": "Once a suitable service has been discovered, there will be a price negotiation. The provider may offer the same service at different rates depending on the number of units of service to be purchased. The process is outlined in Figure 5. The outcome of the process is an agreement to purchase an amount of service and a total price for the service to be provided. The service provider can then request payment for the agreed service and price.   Figure 6. IoT Service Negotiation.", 
            "title": "Service Negotiation"
        }, 
        {
            "location": "/architecture/#service-negotiation-apis", 
            "text": "Key  Parameters  Purpose      price_request  service_id  Request a list of all prices for a given service.    price_response  server_UUID , list of prices, ( service_id ,  price_id ,  price_per_unit ,  unit_ID ,  unit_description ,  price_description )  Provide the client with a list of prices for a given service. A price object contains the per unit price.    price_select  service_id ,  price_id ,  number_of_units ,  client_UUID  Select a price with  price_id , for  service_id  for a number of units.    price_select_response  price_id ,  number_of_units ,  total_price ,  server_UUID ,  client_UUID ,  payment_ref_ID ,  Merchant_Client_key  Communicate the expected total price to the client.", 
            "title": "Service Negotiation APIs"
        }, 
        {
            "location": "/architecture/#service-negotiation-messages", 
            "text": "A price request is sent containing the selected service_id.  The response from Thing B contains a list of price items; each item should contain a  price_id , per unit price,  unit_ID  and description fields of both the unit and the price.  Thing A then selects an appropriate  price_id  by sending a request with its  client_UUID , the selected  service_id , the  price_id , and the number of items required.  If the number of items falls within the correct number of items for the price selected, then Thing B responds with a price select response containing the  service_id ,  price_id , the total price, the  service_UUID  and a reference for the payment and its Merchant Client key. Otherwise Thing B shall return the number of units it can supply along with the correct price, and additional details required to initiate the payment.", 
            "title": "Service negotiation messages"
        }, 
        {
            "location": "/architecture/#payment", 
            "text": "The payment process with Worldpay is a two stage process, split between the consumer and merchant Things involved in the transaction, these stages are:    Client Token Request, and    Payment Authorisation Request. (Also known as Order Request)    During the first stage, the consumer sends Worldpay their payment credentials and the merchants Client Key. We return a Client Token, which the consumer passes to the Merchant. This allows the merchant to perform the payment authorisation request with Worldpay by providing the Client Token and transaction details.  This payment process ensures that the consumer does not pass their payment credentials to the merchant, only to Worldpay.", 
            "title": "Payment"
        }, 
        {
            "location": "/architecture/#client-token-request", 
            "text": "The first step in the payment process is when Thing A receives the  Merchant_Client_Key  from Thing B. Thing B passes their public Client Key to Thing A as part of the  price_select_response  during the Service Negotiation phase. Upon receiving the Client Key from Thing B, Thing A connects with Worldpay to request the client token from us. This request includes Thing A\u2019s payment credentials: Card PAN, expiry, and the  client_key  of Thing B. Worldpay will respond with a message that includes a  client_token . This is shown in Figure 7.   Figure 7. IoT Payment process - client token request.", 
            "title": "Client token request"
        }, 
        {
            "location": "/architecture/#client-token-request-apis", 
            "text": "", 
            "title": "Client token request APIs"
        }, 
        {
            "location": "/architecture/#thing-a-to-worldpay-client-token-request", 
            "text": "Key  Parameters  Purpose      client_token_request  Payment_method ,  reusable_flag ,  Merchant_client_key ,  Payment_method  ( name ,  PAN ,  expiryMonth ,  expiryYear ,  type )  Request a client token from Worldpay, whilst providing us with the payment credentials.    client_token_response  client_token ,  reusable_flag ,  payment_method_response  ( type ,  name ,  expiryMonth ,  expiryYear ,  card\\_type ,  card\\_scheme\\_type ,  card\\_scheme\\_name ,  masked\\_card\\_number ,  card\\_product\\_type\\_description\\_non\\_contactless ,  card\\_product\\_type\\_description\\_contactless ,  card\\_issuer ,  country\\_code ,  card\\_class ,  pre-paid )  Response from Worldpay containing the client_token.    Payment_request  client_token ,  client_UUID ,  payment_ref_ID  The  client_token  is passed to Thing B to allow the 2 nd  part of the transaction process to take place.     Thing A will connect to Worldpay using Transport Layer Security (TLS). It will then request a  client_token  by securely (see 2.2.1) sending a JSON message containing the  paymentMethod , its payment credentials (PAN, expiry) to us, along with the  client_ key  from Thing B. In addition a flag indicating if the client details can be used in future is sent, for IoT this should always be set \u2018reusable\u2019:\u2019false\u2019 in order to force generation of a new client token for each transaction.  A successful response will be an HTTP  POST  response containing fields:  client_token ,  reusable_flag  and the  payment_method_response . Once received, the  client_token  shall be passed to Thing B.  A sample request is shown in Appendix B: Sample Service Messaging.  See  API keys  for documentation for  client_token_request  and  client_token_repsonse  APIs data descriptions.", 
            "title": "Thing A to Worldpay client token request"
        }, 
        {
            "location": "/architecture/#payment-authorisation-request", 
            "text": "Thing B will process the order and request the payment from Worldpay providing its service key,  client_token , transaction currency and payment amount. This is transmitted to Worldpay over TLS. After successful processing the payment, Worldpay will provide a payment response. Thing B shall then generate a service token, which Thing A may use in future to obtain the services that the payment has been made for. This is shown in Figure 7.   Figure 8. Payment Authorisation Request.", 
            "title": "Payment authorisation request"
        }, 
        {
            "location": "/architecture/#payment-authorisation-request-apis", 
            "text": "", 
            "title": "Payment authorisation request APIs"
        }, 
        {
            "location": "/architecture/#thing-b-to-worldpay-payment-authorisation-request", 
            "text": "Key  Parameters  Purpose      order_request  client_service_key ,  client_token ,  currency_code ,  amount ,  order_description ,  customer_order_code  Request payment from Worldpay.    order_response  order_code ,  client_token ,  order_description ,  amount ,  currency_code ,  payment_status ,  customer_order_code ,  environment ,  risk_score ,  payment_response  ( type ,  name ,  expiryMonth ,  expiryYear ,  card\\_type ,  card\\_scheme\\_type ,  card\\_scheme\\_name ,  masked\\_card\\_number ,  card\\_product\\_type\\_description\\_non\\_contactless ,  card\\_product\\_type\\_description\\_contactless ,  card\\_issuer ,  country\\_code ,  card\\_class ,  pre-paid )  Payment response indicating a successful transaction on the Worldpay platform.     Thing B will assemble a message to be posted to Worldpay that contains the client token, Service key, the amount, currency and transaction description. We will then perform an authorisation using the payment credentials identified by the  client_token . A successful authorisation will result in a  payment_status  of SUCCESS being returned to Thing B.", 
            "title": "Thing B to Worldpay payment authorisation request"
        }, 
        {
            "location": "/architecture/#thing-b-to-thing-a-service-token", 
            "text": "Key  Parameters  Purpose      payment_request_response  service_delivery_token ,  server_UUID ,  client_UUID ,  total_paid  service_delivery_token  is passed to ThingB.     Thing B shall then generate a cryptographically secure  service_delivery_token , which can be used by Thing A to request provision of services from Thing B.", 
            "title": "Thing B to Thing A service token"
        }, 
        {
            "location": "/architecture/#service-delivery", 
            "text": "Once the payment has been made, Thing B shall return to broadcasting its available services. Thing A will now be able to consume the service from Thing B by providing the  service_delivery_token . The service delivery may be in a single step, or over time. An overview of service delivery is shown in Figure 8.   Figure 8. Service delivery.  Once in possession of a service_token, Thing A may then request the service be provided. The service could be consumed in one session, or in several sessions over time, depending on the nature of the service and number of units purchased. Thing A may repeatedly send service delivery requests until Thing B indicates that the service has been delivered.", 
            "title": "Service Delivery"
        }, 
        {
            "location": "/architecture/#service-delivery-apis", 
            "text": "Key  Parameters  Purpose      payment_request_response  service_delivery_token ,  server_UUID ,  client_UUID ,  total_paid  service_delivery_token  is passed to ThingB.    broadcast  server_UUID  Advertising services and identifying the sender.    delivery_begin_request  service_delivery_token ,  client_UUID ,  number_of_units_to_supply  Request the service item, with the  service_delivery_token  providing right to receive the service, and amount of service to be supplied.    delivery_begin_response  server_UUID ,  service_delivery_token ,  client_UUID ,  number_of_units_to_be_supplied  Response for the service delivery. Confirmation of number of service units to be supplied (Allowing for less units than requested).    delivery_end  client_UUID ,  number_of_units_received  Confirmation of service received.    delivery_end_response  server_UUID ,  service_delivery_token ,  client_UUID ,  number_of_units_just_supplied ,  number_of_units_remaining  Service end indicating outstanding service credits and token for subsequent delivery.     Thing A sends a message with the  service_delivery_token  to Thing B, along with the amount of service it wishes to consume. The response shall confirm the amount of service units that Thing B can supply to Thing A at that time. Once the service has been delivered, Thing A shall confirm the amount of service units it has received, with Thing B responding, stating the number of units still remaining to Thing A, if any.", 
            "title": "Service Delivery APIs"
        }, 
        {
            "location": "/architecture/#useful-terms", 
            "text": "A few useful terms we're making quite a lot of use of, and if you are new to the world of payments these may be unfamiliar to you!     Term  Definition      API  Application Programming Interface    Worldpay  Worldpay Open Payment API,  https://online.worldpay.com/    HCE  Host Card Emulation    HTE  Host Terminal Emulation    HTTPS  HyperText Transfer Protocol Secure    IoT  Internet of Things    P2PE  Point to Point Encryption    TLS  Transport Layer Security    UUID  Universally Unique Identifier    RPC  Remote Procedure Call", 
            "title": "Useful terms"
        }, 
        {
            "location": "/internal-structure/", 
            "text": "Internal Structure of Worldpay Within\n\n\nWhat is Worldpay Within and what does it do\n\n\nWorldpay Within is an embeddable payments agent for the Internet of Things (IoT) that can be 'plugged' into your smart device app, enabling it to discover, pay for, and consume the services of other devices. Conversely it also allows your smart device to expose services to consumer devices, receive payments for those services, and then release services to a consumer using the idea of a \n'Trusted Trigger'.\n\n\nIt is all about enabling payments in IoT, allowing smart devices to communicate with each other and exchange value for services.\n\n\nConsumers and producers\n\n\nA consumer (shopper) is a smart device which is looking for services, pays for services and consumes services.\n\n\nA producer (merchant) is a smart device that is able to advertise availability of it's owner services to consumers, take a payment, and release those services to the trusted consumer that made the payment.\n\n\nHow could I use it?\n\n\n\n\nWhat Worldpay Within Does.\n\n\nThe example above has a smart car looking for parking, and paying a smart parking meter for parking in it's bay. The smart car \"wants to park\", so has HCE (Host Card Emulation; card credentials) - it acts as a shopper. When trying to make a payment, it will connect to the Worldpay online payments gateway and request tokenised card credentials based on the smart device it is trying to consume services from.\n\n\nThis token is then securely passed to the parking meter. In this case the parking meter is the Producer, or is acting as the merchant, or HTE (Host Terminal Emulation, accepting payment), which then directly communicates with the Worldpay gateway to make a 'card on file' or 'eCommerce' type payment authorisation request. With the payment authorised it then releases the purchased service to the consumer.\n\n\nThe beauty of Worldpay Within is that it enables smart devices to both make payments and receive payments. In the example above the parking meter could then go on to make payments to the electricity companies smart hub which is powering it.\n\n\nHow the Wrapper works\n\n\n\n\nHow the Wrapper Works.\n\n\nOn the left-hand side you have the SDK, on the right-hand side you have the Wrapper, in this case the Java Core. The SDK in Golang has an RPC layer on top which is exposed via Thrift. The Java Core or Wrapper, is built up of the Thrift layer which does the RPC comms to the core SDK. The wrapper also acts as an adapter converting all the data / objects / errors into Pojos that the Java core, or the app you are building can work with.\n\n\nThe important thing to recognise here is that none of the Thrift layer is exposed to you as a developer, and all the RPC calls are handled for you, so essentially you are calling the Worldpay Within seamlessly, managed by the Worldpay Within Wrapper in the appropriate language you are working in.\n\n\nHow the wrapper and SDK work\n\n\n\n\nHow the wrapper and SDK work.\n\n\nThis is another view of the SDK and the app - in this scenario there are two devices with Worldpay Within installed on them, communicating over the internet. One is the 'consumer' and the other is the 'producer', as explained above. As you go down the layers, you have the RPC layer, then the Thrift layer and finally the wrapper layer (above) to communicate with the SDK via RPC calls What is not shown is your app will be the next layer shown on the diagram.\n\n\nIn this scenario, the producer is UDP broadcasting a service message, which includes what its hostname, IP and UrlPrefix are. Once the consumer does device discovery, it is able to communicate over HTTP with the restful endpoint on the producer to find out what services it offers, and then begins the rest of the flow.\n\n\nWhat's happening inside the SDK\n\n\nFor the first release we have open sourced the wrappers and example apps, but kept the internals of the Golang SDK closed source. As the project goes on we'll consider open sourcing this component too.\n\n\nIt is of course useful to know exactly what is happening inside this black box, so the below page details the architecture of Worldpay Within and what is happening in the internals.\n\n\nThe Worldpay Within Architecture", 
            "title": "Internal structure"
        }, 
        {
            "location": "/internal-structure/#internal-structure-of-worldpay-within", 
            "text": "", 
            "title": "Internal Structure of Worldpay Within"
        }, 
        {
            "location": "/internal-structure/#what-is-worldpay-within-and-what-does-it-do", 
            "text": "Worldpay Within is an embeddable payments agent for the Internet of Things (IoT) that can be 'plugged' into your smart device app, enabling it to discover, pay for, and consume the services of other devices. Conversely it also allows your smart device to expose services to consumer devices, receive payments for those services, and then release services to a consumer using the idea of a  'Trusted Trigger'.  It is all about enabling payments in IoT, allowing smart devices to communicate with each other and exchange value for services.", 
            "title": "What is Worldpay Within and what does it do"
        }, 
        {
            "location": "/internal-structure/#consumers-and-producers", 
            "text": "A consumer (shopper) is a smart device which is looking for services, pays for services and consumes services.  A producer (merchant) is a smart device that is able to advertise availability of it's owner services to consumers, take a payment, and release those services to the trusted consumer that made the payment.", 
            "title": "Consumers and producers"
        }, 
        {
            "location": "/internal-structure/#how-could-i-use-it", 
            "text": "What Worldpay Within Does.  The example above has a smart car looking for parking, and paying a smart parking meter for parking in it's bay. The smart car \"wants to park\", so has HCE (Host Card Emulation; card credentials) - it acts as a shopper. When trying to make a payment, it will connect to the Worldpay online payments gateway and request tokenised card credentials based on the smart device it is trying to consume services from.  This token is then securely passed to the parking meter. In this case the parking meter is the Producer, or is acting as the merchant, or HTE (Host Terminal Emulation, accepting payment), which then directly communicates with the Worldpay gateway to make a 'card on file' or 'eCommerce' type payment authorisation request. With the payment authorised it then releases the purchased service to the consumer.  The beauty of Worldpay Within is that it enables smart devices to both make payments and receive payments. In the example above the parking meter could then go on to make payments to the electricity companies smart hub which is powering it.", 
            "title": "How could I use it?"
        }, 
        {
            "location": "/internal-structure/#how-the-wrapper-works", 
            "text": "How the Wrapper Works.  On the left-hand side you have the SDK, on the right-hand side you have the Wrapper, in this case the Java Core. The SDK in Golang has an RPC layer on top which is exposed via Thrift. The Java Core or Wrapper, is built up of the Thrift layer which does the RPC comms to the core SDK. The wrapper also acts as an adapter converting all the data / objects / errors into Pojos that the Java core, or the app you are building can work with.  The important thing to recognise here is that none of the Thrift layer is exposed to you as a developer, and all the RPC calls are handled for you, so essentially you are calling the Worldpay Within seamlessly, managed by the Worldpay Within Wrapper in the appropriate language you are working in.", 
            "title": "How the Wrapper works"
        }, 
        {
            "location": "/internal-structure/#how-the-wrapper-and-sdk-work", 
            "text": "How the wrapper and SDK work.  This is another view of the SDK and the app - in this scenario there are two devices with Worldpay Within installed on them, communicating over the internet. One is the 'consumer' and the other is the 'producer', as explained above. As you go down the layers, you have the RPC layer, then the Thrift layer and finally the wrapper layer (above) to communicate with the SDK via RPC calls What is not shown is your app will be the next layer shown on the diagram.  In this scenario, the producer is UDP broadcasting a service message, which includes what its hostname, IP and UrlPrefix are. Once the consumer does device discovery, it is able to communicate over HTTP with the restful endpoint on the producer to find out what services it offers, and then begins the rest of the flow.", 
            "title": "How the wrapper and SDK work"
        }, 
        {
            "location": "/internal-structure/#whats-happening-inside-the-sdk", 
            "text": "For the first release we have open sourced the wrappers and example apps, but kept the internals of the Golang SDK closed source. As the project goes on we'll consider open sourcing this component too.  It is of course useful to know exactly what is happening inside this black box, so the below page details the architecture of Worldpay Within and what is happening in the internals.  The Worldpay Within Architecture", 
            "title": "What's happening inside the SDK"
        }, 
        {
            "location": "/sample-service-messaging/", 
            "text": "Summary\n\n\nThis is an early reference guide which has evolved since it was first published. However, in combination with the SDK code, it should give you plenty of hints as to how to work with the SDK. \n\n\n\n\nService discovery messages\n\n\nWe're going to build a reference application to prove the concepts and APIs outlined above. This reference application will be implemented on the current range of platforms aimed at providing IoT services. These boards are typically running \u2018M\u2019 class processors which as yet do not contain an SE. Currently only the application processors (A class such as A57 Cortex) contain SEs. However developments are being made in the IoT platform space, for example ARM has released a new M architecture with does contain an SE, although there will be delay before boards using these processors and compiler tools become mainstream. This document requires these more secure platforms to be available.\n\n\nService broadcast\n\n\n!#js\n\n{\n    \nDeviceDescription\n: \nWorldpay Within Enabled Electric Car Charger\n,\n    \nHostname\n: \n192.168.1.139\n,\n    \nPortNumber\n: 8800,\n    \nServerID\n: \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n    \nUrlPrefix\n: \nv1/carcharge\n\n}\n\n\n\n\n\nService list request\n\n\nIn order to build the URL, use the hostname and the port number, then concatenate the URL with \u201cservice/discover\u201d.\n\n\nhttp://192.168.1.139:8800/v1/carcharge/service/discover\n\n\n{\n}\n\n\n\n\n\n\n\nNote\n\n\nThe body content is empty; the request is direct to the server, which is indicated in the broadcast.\n\n\n\n\nService list response\n\n\n!#js\n{\n\nServerID\n: \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n\nServices\n: [\n    {\n        \nServiceID\n: 0,\n        \nServiceDescription\n: \nCar charging\n\n    },\n    {\n        \nServiceID\n: 1,\n        \nServiceDescription\n: \nCar parking\n\n    }\n]\n}\n\n\n\n\n\nService negotiation messages\n\n\nService price request\n\n\nIn order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \u201cservice ID\u201d and then \u201cprices\u201d.\n\n\nhttp://192.168.1.139:8800/v1/carcharge/service/0/prices\n\n\n{\n}\n\n\n\n\n\nNote: body content empty. URL includes the serviceID (i.e. 0) for the prices being requested, e.g. for serviceID 1, URL would be /v1/carcharge/service/1/prices)\n\n\nService price response\n\n\n!#js\n{\n    \nServerID\n : \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n    \nPrices\n : [{\n        \nServiceID\n : 0,\n        \nPriceID\n : 0,\n        \nPricePerUnit\n : 140,\n        \nUnitID\n : 0,\n        \nUnitDescription\n : \nkW\n,\n        \nPriceDescription\n : \nSlow (3.6kWh)\n\n    }, {\n        \nServiceID\n : 0,\n        \nPriceID\n : 1,\n        \nPricePerUnit\n : 70,\n        \nUnitID\n : 0,\n        \nUnitDescription\n : \nkW\n,\n        \nPriceDescription\n : \nMedium (7.2kWh)\n\n    }, {\n        \nServiceID\n : 0,\n        \nPriceID\n : 2,\n        \nPricePerUnit\n : 10,\n        \nUnitID\n : 0,\n        \nUnitDescription\n : \nkW\n,\n        \nPriceDescription\n : \nSuper (120kWh)\n\n    }\n    ]\n}\n\n\n\n\n\nGet Total price request\n\n\nIn order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \u201cservice ID\u201d and then \u201crequestTotal\u201d.\n\n\nhttp://192.168.1.139:8800/v1/carcharge/service/0/requestTotal\n\nContent: \n\n\n!#js\n{\n    \nClientID\n:\n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nSelectedNumberOfUnits\n:8,\n    \nSelectedPriceID\n:1\n}\n\n\n\n\n\nGet Total price response\n\n\n!#js\n{\n    \nServerID\n: \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n    \nClientID\n: \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nPriceID\n: 1,\n    \nUnitsToSupply\n: 8,\n    \nTotalPrice\n: 560,\n    \nPaymentReferenceID\n: \ne7c18800-706d-4f0c-933c-19f8d5be72da\n,\n    \nMerchantClientKey\n: \n T_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx \n\n}\n\n\n\n\n\nToken request for Online.worldpay.com\n\n\nHTTP POST to \nhttps://api.worldpay.com/v1/tokens\n. No custom HTTP headers used.\n\n\n!#js\n{\n    \nclientKey\n : \nT_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n,\n    \npaymentMethod\n : {\n        \ncardNumber\n : \n1234567890124444\n,\n        \nexpiryMonth\n : 2,\n        \nexpiryYear\n : 2021,\n        \nname\n : \nBilbo Baggins\n,\n        \ntype\n : \nCard\n\n    },\n    \nreusable\n : false\n}\n\n\n\n\n\nToken response content from Online.worldpay.com\n\n\n!#js\n{\n    \ntoken\n: \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\n,\n    \npaymentMethod\n: {\n        \ntype\n: \nObfuscatedCard\n,\n        \nname\n: \nBilbo Baggins\n,\n        \nexpiryMonth\n: 2,\n        \nexpiryYear\n: 2021,\n        \ncardType\n: \nMASTERCARD_CREDIT\n,\n        \nmaskedCardNumber\n: \n**** **** **** 4444\n,\n        \ncardSchemeType\n: \nconsumer\n,\n        \ncardSchemeName\n: \nMCI CREDIT\n,\n        \ncardIssuer\n: \nLLOYDS BANK PLC\n,\n        \ncountryCode\n: \nGB\n,\n        \ncardClass\n: \ncredit\n,\n        \ncardProductTypeDescNonContactless\n: \nMasterCard Business\n,\n        \ncardProductTypeDescContactless\n: \nCL MasterCard Bus\n,\n        \nprepaid\n: \nunknown\n\n    },\n    \nreusable\n: false\n}\n\n\n\n\n\nPayment request\n\n\nHTTP POST to \nhttp://192.168.1.139:8800/v1/carcharge/payment\n\n\n!#js\n{\n    \nClientID\n : \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nClientToken\n : \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy \n,\n    \nPaymentReferenceID\n : \ne7c18800-706d-4f0c-933c-19f8d5be72da\n\n}\n\n\n\n\n\nOrder request for Online.worldpay.com\n\n\nHTTP POST to \nhttps://api.worldpay.com/v1/orders\n. HTTP header includes the Merchant's Service Key (Private)\n\n\n!#js\n{\n    \namount\n : 560,\n    \ncurrencyCode\n : \nGBP\n,\n    \ncustomerOrderCode\n : \nCar charge (8kW @ Medium (7.2kWh)) - 26\\/01\\/2016 15:40\n,\n    \norderDescription\n : \nCar charging payment\n,\n    \ntoken\n : \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy \n\n}\n\n\n\n\n\nOrder response content from Online.worldpay.com\n\n\n!#js\n{\n    \norderCode\n : \n4d22cb5d-5dfb-43ce-9108-dfe230151429\n,\n    \ntoken\n : \nTEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy \n,\n    \norderDescription\n : \nCar charging payment\n,\n    \namount\n : 560,\n    \ncurrencyCode\n : \nGBP\n,\n    \npaymentStatus\n : \nSUCCESS\n,\n    \npaymentResponse\n : {\n        \ntype\n : \nObfuscatedCard\n,\n        \nname\n : \nBilbo Baggins\n,\n        \nexpiryMonth\n : 2,\n        \nexpiryYear\n : 2021,\n        \ncardType\n : \nMASTERCARD_CREDIT\n,\n        \nmaskedCardNumber\n : \n**** **** **** 4444\n,\n        \ncardSchemeType\n : \nconsumer\n,\n        \ncardSchemeName\n : \nMCI CREDIT\n,\n        \ncardIssuer\n : \nLLOYDS BANK PLC\n,\n        \ncountryCode\n : \nGB\n,\n        \ncardClass\n : \ncredit\n,\n        \ncardProductTypeDescNonContactless\n : \nMasterCard Business\n,\n        \ncardProductTypeDescContactless\n : \nCL MasterCard Bus\n,\n        \nprepaid\n : \nunknown\n\n    },\n    \ncustomerOrderCode\n : \nCar charge (8kW @ Medium (7.2kWh)) - 26/01/2016 15:40\n,\n    \nenvironment\n : \nTEST\n,\n    \nriskScore\n : {\n        \nvalue\n : \n1\n\n    }\n}\n\n\n\n\n\nPayment request response\n\n\n!#js\n{\n    \nServerID\n : \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n    \nClientID\n : \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nTotalPaid\n : 0,\n    \nServiceDeliveryToken\n : \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n    \nclient-uuid\n:\n719D329B-8909-4A8B-B352-E449C3132074\n\n}\n\n\n\n\n\nBegin Service Delivery request\n\n\nHTTP POST to \nhttp://192.168.1.139:8800/v1/carcharge/service/0/delivery/begin\n\n\nURL encodes the serviceID being requested\n\n\n!#js\n{\n    \nClientID\n : \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nServiceDeliveryToken\n : \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n    \nUnitsToSupply\n : 8\n}\n\n\n\n\n\nBegin Service Delivery response content:\n\n\n!#js\n{\n    \nServerID\n : \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n    \nClientID\n : \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nServiceDeliveryToken\n : \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n    \nUnitsToSupply\n : 8\n}\n\n\n\n\n\nEnd Service Delivery request\n\n\nHTTP POST to \nhttp://192.168.1.139:8800/v1/carcharge/service/0/delivery/end\n)\n\n\nURL encodes the serviceID being requested\n\n\n!#js\n{\n    \nClientID\n : \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nServiceDeliveryToken\n : \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n    \nUnitsReceived\n : 8\n}\n\n\n\n\n\nEnd Service Delivery response content\n\n\n!#js\n{\n    \nServerID\n : \n58d8f9fb-b3e9-45bc-b701-fcdd295bc265\n,\n    \nClientID\n : \n54560ba2-87c0-4172-a904-67a9b7a5e1ee\n,\n    \nServiceDeliveryToken\n : \n3e7b4c25-157d-4b47-999c-e4faba086590\n,\n    \nUnitsJustSupplied\n : 8,\n    \nUnitsRemaining\n : 0\n}", 
            "title": "Sample service messaging"
        }, 
        {
            "location": "/sample-service-messaging/#service-discovery-messages", 
            "text": "We're going to build a reference application to prove the concepts and APIs outlined above. This reference application will be implemented on the current range of platforms aimed at providing IoT services. These boards are typically running \u2018M\u2019 class processors which as yet do not contain an SE. Currently only the application processors (A class such as A57 Cortex) contain SEs. However developments are being made in the IoT platform space, for example ARM has released a new M architecture with does contain an SE, although there will be delay before boards using these processors and compiler tools become mainstream. This document requires these more secure platforms to be available.", 
            "title": "Service discovery messages"
        }, 
        {
            "location": "/sample-service-messaging/#service-broadcast", 
            "text": "!#js\n\n{\n     DeviceDescription :  Worldpay Within Enabled Electric Car Charger ,\n     Hostname :  192.168.1.139 ,\n     PortNumber : 8800,\n     ServerID :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 ,\n     UrlPrefix :  v1/carcharge \n}", 
            "title": "Service broadcast"
        }, 
        {
            "location": "/sample-service-messaging/#service-list-request", 
            "text": "In order to build the URL, use the hostname and the port number, then concatenate the URL with \u201cservice/discover\u201d.  http://192.168.1.139:8800/v1/carcharge/service/discover  {\n}   Note  The body content is empty; the request is direct to the server, which is indicated in the broadcast.", 
            "title": "Service list request"
        }, 
        {
            "location": "/sample-service-messaging/#service-list-response", 
            "text": "!#js\n{ ServerID :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 , Services : [\n    {\n         ServiceID : 0,\n         ServiceDescription :  Car charging \n    },\n    {\n         ServiceID : 1,\n         ServiceDescription :  Car parking \n    }\n]\n}", 
            "title": "Service list response"
        }, 
        {
            "location": "/sample-service-messaging/#service-negotiation-messages", 
            "text": "", 
            "title": "Service negotiation messages"
        }, 
        {
            "location": "/sample-service-messaging/#service-price-request", 
            "text": "In order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \u201cservice ID\u201d and then \u201cprices\u201d.  http://192.168.1.139:8800/v1/carcharge/service/0/prices  {\n}  Note: body content empty. URL includes the serviceID (i.e. 0) for the prices being requested, e.g. for serviceID 1, URL would be /v1/carcharge/service/1/prices)", 
            "title": "Service price request"
        }, 
        {
            "location": "/sample-service-messaging/#service-price-response", 
            "text": "!#js\n{\n     ServerID  :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 ,\n     Prices  : [{\n         ServiceID  : 0,\n         PriceID  : 0,\n         PricePerUnit  : 140,\n         UnitID  : 0,\n         UnitDescription  :  kW ,\n         PriceDescription  :  Slow (3.6kWh) \n    }, {\n         ServiceID  : 0,\n         PriceID  : 1,\n         PricePerUnit  : 70,\n         UnitID  : 0,\n         UnitDescription  :  kW ,\n         PriceDescription  :  Medium (7.2kWh) \n    }, {\n         ServiceID  : 0,\n         PriceID  : 2,\n         PricePerUnit  : 10,\n         UnitID  : 0,\n         UnitDescription  :  kW ,\n         PriceDescription  :  Super (120kWh) \n    }\n    ]\n}", 
            "title": "Service price response"
        }, 
        {
            "location": "/sample-service-messaging/#get-total-price-request", 
            "text": "In order to build the URL, use the hostname, with the port number, the url prefix all concatenated. The concatenate with \u201cservice\u201d concatenated with \u201cservice ID\u201d and then \u201crequestTotal\u201d.  http://192.168.1.139:8800/v1/carcharge/service/0/requestTotal \nContent:   !#js\n{\n     ClientID : 54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     SelectedNumberOfUnits :8,\n     SelectedPriceID :1\n}", 
            "title": "Get Total price request"
        }, 
        {
            "location": "/sample-service-messaging/#get-total-price-response", 
            "text": "!#js\n{\n     ServerID :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 ,\n     ClientID :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     PriceID : 1,\n     UnitsToSupply : 8,\n     TotalPrice : 560,\n     PaymentReferenceID :  e7c18800-706d-4f0c-933c-19f8d5be72da ,\n     MerchantClientKey :   T_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx  \n}", 
            "title": "Get Total price response"
        }, 
        {
            "location": "/sample-service-messaging/#token-request-for-onlineworldpaycom", 
            "text": "HTTP POST to  https://api.worldpay.com/v1/tokens . No custom HTTP headers used.  !#js\n{\n     clientKey  :  T_C_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx ,\n     paymentMethod  : {\n         cardNumber  :  1234567890124444 ,\n         expiryMonth  : 2,\n         expiryYear  : 2021,\n         name  :  Bilbo Baggins ,\n         type  :  Card \n    },\n     reusable  : false\n}", 
            "title": "Token request for Online.worldpay.com"
        }, 
        {
            "location": "/sample-service-messaging/#token-response-content-from-onlineworldpaycom", 
            "text": "!#js\n{\n     token :  TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy ,\n     paymentMethod : {\n         type :  ObfuscatedCard ,\n         name :  Bilbo Baggins ,\n         expiryMonth : 2,\n         expiryYear : 2021,\n         cardType :  MASTERCARD_CREDIT ,\n         maskedCardNumber :  **** **** **** 4444 ,\n         cardSchemeType :  consumer ,\n         cardSchemeName :  MCI CREDIT ,\n         cardIssuer :  LLOYDS BANK PLC ,\n         countryCode :  GB ,\n         cardClass :  credit ,\n         cardProductTypeDescNonContactless :  MasterCard Business ,\n         cardProductTypeDescContactless :  CL MasterCard Bus ,\n         prepaid :  unknown \n    },\n     reusable : false\n}", 
            "title": "Token response content from Online.worldpay.com"
        }, 
        {
            "location": "/sample-service-messaging/#payment-request", 
            "text": "HTTP POST to  http://192.168.1.139:8800/v1/carcharge/payment  !#js\n{\n     ClientID  :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     ClientToken  :  TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy  ,\n     PaymentReferenceID  :  e7c18800-706d-4f0c-933c-19f8d5be72da \n}", 
            "title": "Payment request"
        }, 
        {
            "location": "/sample-service-messaging/#order-request-for-onlineworldpaycom", 
            "text": "HTTP POST to  https://api.worldpay.com/v1/orders . HTTP header includes the Merchant's Service Key (Private)  !#js\n{\n     amount  : 560,\n     currencyCode  :  GBP ,\n     customerOrderCode  :  Car charge (8kW @ Medium (7.2kWh)) - 26\\/01\\/2016 15:40 ,\n     orderDescription  :  Car charging payment ,\n     token  :  TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy  \n}", 
            "title": "Order request for Online.worldpay.com"
        }, 
        {
            "location": "/sample-service-messaging/#order-response-content-from-onlineworldpaycom", 
            "text": "!#js\n{\n     orderCode  :  4d22cb5d-5dfb-43ce-9108-dfe230151429 ,\n     token  :  TEST_SU_yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy  ,\n     orderDescription  :  Car charging payment ,\n     amount  : 560,\n     currencyCode  :  GBP ,\n     paymentStatus  :  SUCCESS ,\n     paymentResponse  : {\n         type  :  ObfuscatedCard ,\n         name  :  Bilbo Baggins ,\n         expiryMonth  : 2,\n         expiryYear  : 2021,\n         cardType  :  MASTERCARD_CREDIT ,\n         maskedCardNumber  :  **** **** **** 4444 ,\n         cardSchemeType  :  consumer ,\n         cardSchemeName  :  MCI CREDIT ,\n         cardIssuer  :  LLOYDS BANK PLC ,\n         countryCode  :  GB ,\n         cardClass  :  credit ,\n         cardProductTypeDescNonContactless  :  MasterCard Business ,\n         cardProductTypeDescContactless  :  CL MasterCard Bus ,\n         prepaid  :  unknown \n    },\n     customerOrderCode  :  Car charge (8kW @ Medium (7.2kWh)) - 26/01/2016 15:40 ,\n     environment  :  TEST ,\n     riskScore  : {\n         value  :  1 \n    }\n}", 
            "title": "Order response content from Online.worldpay.com"
        }, 
        {
            "location": "/sample-service-messaging/#payment-request-response", 
            "text": "!#js\n{\n     ServerID  :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 ,\n     ClientID  :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     TotalPaid  : 0,\n     ServiceDeliveryToken  :  3e7b4c25-157d-4b47-999c-e4faba086590 ,\n     client-uuid : 719D329B-8909-4A8B-B352-E449C3132074 \n}", 
            "title": "Payment request response"
        }, 
        {
            "location": "/sample-service-messaging/#begin-service-delivery-request", 
            "text": "HTTP POST to  http://192.168.1.139:8800/v1/carcharge/service/0/delivery/begin  URL encodes the serviceID being requested  !#js\n{\n     ClientID  :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     ServiceDeliveryToken  :  3e7b4c25-157d-4b47-999c-e4faba086590 ,\n     UnitsToSupply  : 8\n}", 
            "title": "Begin Service Delivery request"
        }, 
        {
            "location": "/sample-service-messaging/#begin-service-delivery-response-content", 
            "text": "!#js\n{\n     ServerID  :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 ,\n     ClientID  :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     ServiceDeliveryToken  :  3e7b4c25-157d-4b47-999c-e4faba086590 ,\n     UnitsToSupply  : 8\n}", 
            "title": "Begin Service Delivery response content:"
        }, 
        {
            "location": "/sample-service-messaging/#end-service-delivery-request", 
            "text": "HTTP POST to  http://192.168.1.139:8800/v1/carcharge/service/0/delivery/end )  URL encodes the serviceID being requested  !#js\n{\n     ClientID  :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     ServiceDeliveryToken  :  3e7b4c25-157d-4b47-999c-e4faba086590 ,\n     UnitsReceived  : 8\n}", 
            "title": "End Service Delivery request"
        }, 
        {
            "location": "/sample-service-messaging/#end-service-delivery-response-content", 
            "text": "!#js\n{\n     ServerID  :  58d8f9fb-b3e9-45bc-b701-fcdd295bc265 ,\n     ClientID  :  54560ba2-87c0-4172-a904-67a9b7a5e1ee ,\n     ServiceDeliveryToken  :  3e7b4c25-157d-4b47-999c-e4faba086590 ,\n     UnitsJustSupplied  : 8,\n     UnitsRemaining  : 0\n}", 
            "title": "End Service Delivery response content"
        }, 
        {
            "location": "/api-spec/", 
            "text": "For the alpha release, we made the decision to go with four different wrappers. Their documented API can be found here:\n\n\n\n  \nJava (Javadoc)\n\n  \nPython 2.7 doc\n\n  \n.net / C# doc\n\n  \nNode.js doc\n\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetup\n\n\nSets up the wrapper to be able to start communicating with the underlying SDK.\n\n\n\n\n\n\naddService\n\n\nAdds a service of type WWService to the producer (merchant). Used if the device you are operating on is a producer. If added to a device you intend as a consumer (shopper), this will give that device producer functionality.\n\n\n\n\n\n\nremoveService\n\n\nRemoves the service from the producer.\n\n\n\n\n\n\ninitConsumer\n\n\nInitiates the device as a consumer, which enables it to find services, choose prices, make payments and receive services.\n\n\n\n\n\n\ninitProducer\n\n\nInitiates the device as a producer / or initialises the producer capability.\n\n\n\n\n\n\ngetDevice\n\n\nProvides details of the the current device that the SDK is running on, and its credentials / information.\n\n\n\n\n\n\nstartServiceBroadcast\n\n\nEnables the producer device to start broadcasting itself via UDP broadcast over the network to notify devices it is available to be consumed.\n\n\n\n\n\n\nstopServiceBroadcast\n\n\nStops the SDK from broadcasting the current service messages that it is broadcasting.\n\n\n\n\n\n\ndeviceDiscovery\n\n\nEnables the consumer device to discover other devices (producers) on the network that are UDP broadcasting.\n\n\n\n\n\n\nrequestServices\n\n\nGets a list of services that are available from the broadcasting device.\n\n\n\n\n\n\ngetServicePrices\n\n\nUsed by the consumer to get the list of prices associated with a particular \nserviceId\n\n\n\n\n\n\nselectService\n\n\nPerformed by the consumer, this provides details of the service, the amount and at what price point it wants to purchase the service.\n\n\n\n\n\n\nmakePayment\n\n\nAllows the consumer to request a payment to be made at the producer device, by providing the total price response object as the request. The producer will then make the payment (or attempt to) and send back a payment response detailing whether it was successful or not.\n\n\n\n\n\n\nbeginServiceDelivery\n\n\nRequested by the consumer, this begins the service delivery which proceeds as long as the correct information is provided to the producer. If the correct credentials are passed, the producer will start releasing the service known as a 'trusted trigger'.\n\n\n\n\n\n\nendServiceDelivery\n\n\nEnds the service delivery - a request initiated by the consumer.", 
            "title": "API Spec"
        }, 
        {
            "location": "/api-spec/#specification", 
            "text": "Parameter  Description      setup  Sets up the wrapper to be able to start communicating with the underlying SDK.    addService  Adds a service of type WWService to the producer (merchant). Used if the device you are operating on is a producer. If added to a device you intend as a consumer (shopper), this will give that device producer functionality.    removeService  Removes the service from the producer.    initConsumer  Initiates the device as a consumer, which enables it to find services, choose prices, make payments and receive services.    initProducer  Initiates the device as a producer / or initialises the producer capability.    getDevice  Provides details of the the current device that the SDK is running on, and its credentials / information.    startServiceBroadcast  Enables the producer device to start broadcasting itself via UDP broadcast over the network to notify devices it is available to be consumed.    stopServiceBroadcast  Stops the SDK from broadcasting the current service messages that it is broadcasting.    deviceDiscovery  Enables the consumer device to discover other devices (producers) on the network that are UDP broadcasting.    requestServices  Gets a list of services that are available from the broadcasting device.    getServicePrices  Used by the consumer to get the list of prices associated with a particular  serviceId    selectService  Performed by the consumer, this provides details of the service, the amount and at what price point it wants to purchase the service.    makePayment  Allows the consumer to request a payment to be made at the producer device, by providing the total price response object as the request. The producer will then make the payment (or attempt to) and send back a payment response detailing whether it was successful or not.    beginServiceDelivery  Requested by the consumer, this begins the service delivery which proceeds as long as the correct information is provided to the producer. If the correct credentials are passed, the producer will start releasing the service known as a 'trusted trigger'.    endServiceDelivery  Ends the service delivery - a request initiated by the consumer.", 
            "title": "Specification"
        }
    ]
}